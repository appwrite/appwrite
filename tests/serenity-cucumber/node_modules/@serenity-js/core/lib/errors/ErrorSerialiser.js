"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorSerialiser = void 0;
const tiny_types_1 = require("tiny-types");
/**
 * @group Errors
 */
class ErrorSerialiser {
    static recognisedErrors = [
        // Built-in JavaScript errors
        Error,
        EvalError,
        RangeError,
        ReferenceError,
        SyntaxError,
        TypeError,
        URIError,
    ];
    static serialise(error) {
        if (this.isSerialisable(error)) {
            return JSON.stringify(error.toJSON(), undefined, 0);
        }
        const name = error && error.constructor && error.constructor.name
            ? error.constructor.name
            : error.name;
        const serialisedError = Object.getOwnPropertyNames(error).reduce((serialised, key) => {
            serialised[key] = error[key];
            return serialised;
        }, { name });
        return JSON.stringify(serialisedError, undefined, 0);
    }
    static registerErrorTypes(...types) {
        types.forEach(type => {
            ErrorSerialiser.recognisedErrors.push((0, tiny_types_1.ensure)(`Error type ${type}`, type, (0, tiny_types_1.isDefined)(), (0, tiny_types_1.isFunction)()));
        });
    }
    static deserialise(serialised) {
        if (serialised === null || serialised === undefined) {
            return undefined;
        }
        const serialisedError = typeof serialised === 'string'
            ? JSON.parse(serialised)
            : serialised;
        const constructor = ErrorSerialiser.recognisedErrors.find(errorType => errorType.name === serialisedError.name) || Error;
        if (this.isDeserialisable(constructor)) {
            return constructor.fromJSON(serialisedError);
        }
        const deserialised = Object.create(constructor.prototype);
        for (const property in serialisedError) {
            if (Object.prototype.hasOwnProperty.call(serialisedError, property)) {
                deserialised[property] = serialisedError[property];
            }
        }
        return deserialised;
    }
    static isSerialisable(value) {
        return value
            && typeof value.toJSON === 'function';
    }
    static isDeserialisable(type) {
        return type
            && typeof type.fromJSON === 'function';
    }
    static deserialiseFromStackTrace(stack) {
        const stackTracePattern = /^([^\s:]*Error).*?(?::\s)?(.*?)\n(^ +at.*)$/ms;
        if (!stackTracePattern.test(stack)) {
            return new Error(String(stack));
        }
        const [, name, message, callStack_] = stack.match(stackTracePattern);
        return ErrorSerialiser.deserialise({ name, message: message.trim(), stack });
    }
}
exports.ErrorSerialiser = ErrorSerialiser;
//# sourceMappingURL=ErrorSerialiser.js.map