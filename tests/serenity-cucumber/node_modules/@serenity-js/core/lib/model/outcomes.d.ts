import type { JSONObject } from 'tiny-types';
import { TinyType } from 'tiny-types';
import type { AssertionError } from '../errors';
export interface SerialisedOutcome extends JSONObject {
    code: number;
    error?: string;
}
export declare abstract class Outcome extends TinyType {
    protected readonly code: number;
    static fromJSON: (o: SerialisedOutcome) => Outcome;
    protected constructor(code: number);
    isWorseThan(another: Outcome | {
        Code: number;
    }): boolean;
    toJSON(): SerialisedOutcome;
}
export declare abstract class ProblemIndication extends Outcome {
    readonly error: Error;
    protected constructor(error: Error, code: number);
    toJSON(): SerialisedOutcome;
}
/**
 * Indicates a failure due to external events or systems that compromise the validity of the test.
 */
export declare class ExecutionCompromised extends ProblemIndication {
    static Code: number;
    static fromJSON: (o: SerialisedOutcome) => ExecutionCompromised;
    constructor(error: Error);
}
/**
 * Indicates a failure due to an error other than recognised external system and assertion failures
 */
export declare class ExecutionFailedWithError extends ProblemIndication {
    static Code: number;
    static fromJSON: (o: SerialisedOutcome) => ExecutionFailedWithError;
    constructor(error: Error);
}
/**
 * Execution of an Activity or Scene has failed due to an assertion error;
 */
export declare class ExecutionFailedWithAssertionError extends ProblemIndication {
    static Code: number;
    static fromJSON: (o: SerialisedOutcome) => ExecutionFailedWithAssertionError;
    constructor(error: AssertionError);
}
/**
 * A pending Activity is one that has been specified but not yet implemented.
 * A pending Scene is one that has at least one pending Activity.
 */
export declare class ImplementationPending extends ProblemIndication {
    static Code: number;
    static fromJSON: (o: SerialisedOutcome) => ImplementationPending;
    constructor(error: Error);
}
/**
 * The result of the scenario should be ignored, most likely because it's going to be retried.
 */
export declare class ExecutionIgnored extends ProblemIndication {
    static Code: number;
    static fromJSON: (o: SerialisedOutcome) => ExecutionIgnored;
    constructor(error: Error);
}
/**
 * The Activity was not executed because a previous one has failed.
 * A whole Scene can be marked as skipped to indicate that it is currently "work-in-progress"
 */
export declare class ExecutionSkipped extends Outcome {
    static Code: number;
    static fromJSON: (o: SerialisedOutcome) => ExecutionSkipped;
    constructor();
}
/**
 * Scenario or activity ran as expected.
 */
export declare class ExecutionSuccessful extends Outcome {
    static Code: number;
    static fromJSON: (o: SerialisedOutcome) => ExecutionSuccessful;
    constructor();
}
//# sourceMappingURL=outcomes.d.ts.map