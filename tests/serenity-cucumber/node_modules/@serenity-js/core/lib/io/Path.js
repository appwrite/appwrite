"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Path = void 0;
const filenamify_1 = __importDefault(require("filenamify"));
const tiny_types_1 = require("tiny-types");
const upath_1 = __importStar(require("upath"));
class Path extends tiny_types_1.TinyType {
    static Separator = '/';
    value;
    static fromJSON(v) {
        return new Path(v);
    }
    static fromFileURL(fileUrl) {
        // inspired by https://github.com/TooTallNate/file-uri-to-path
        if (fileUrl.protocol !== 'file:') {
            throw new TypeError(`A Path can be created only from URLs that start with 'file://'. Received: ${fileUrl}`);
        }
        const url = fileUrl.toString();
        const rest = decodeURI(url.slice(7));
        const firstSlash = rest.indexOf('/');
        let host = rest.slice(0, Math.max(0, firstSlash));
        // 2.  Scheme Definition
        // As a special case, <host> can be the string "localhost" or the empty
        // string; this is interpreted as "the machine from which the URL is being interpreted".
        if (host === 'localhost') {
            host = '';
        }
        if (host) {
            host = upath_1.sep + upath_1.sep + host;
        }
        let path = rest.slice(Math.max(0, firstSlash + 1));
        // Drives, drive letters, mount points, file system root
        //
        // Drive letters are mapped into the top of a file URI in various ways, depending on the implementation;
        // some applications substitute vertical bar ("|") for the colon after the drive letter,
        // yielding "file:///c|/tmp/test.txt".
        // In some cases, the colon is left unchanged, as in "file:///c:/tmp/test.txt".
        // In other cases, the colon is simply omitted, as in "file:///c/tmp/test.txt".
        path = path.replace(/^(.+)\|/, '$1:');
        // for Windows, we need to invert the path separators from what a URI uses
        if (upath_1.sep === '\\') {
            path = path.replaceAll('/', '\\');
        }
        if (!(/^.+:/.test(path))) {
            // unix path, because there's no Windows drive at the beginning
            path = upath_1.sep + path;
        }
        return new Path(host + path);
    }
    static from(...segments) {
        if (segments.length === 1 && segments[0].startsWith('file://')) {
            return Path.fromFileURL(new URL(segments[0]));
        }
        return new Path(upath_1.default.joinSafe(...segments));
    }
    static fromSanitisedString(value) {
        const normalised = upath_1.default.normalize(value).replaceAll(/["'/:\\]/gi, ''), extension = upath_1.default.extname(normalised), basename = upath_1.default.basename(normalised, extension), filename = (0, filenamify_1.default)(basename, { replacement: '-', maxLength: 250 })
            .trim()
            .replaceAll(/[\s-]+/g, '-');
        return new Path(upath_1.default.join(upath_1.default.dirname(normalised), `${filename}${extension}`));
    }
    constructor(value) {
        super();
        (0, tiny_types_1.ensure)(Path.name, value, (0, tiny_types_1.isDefined)(), (0, tiny_types_1.property)('length', (0, tiny_types_1.isGreaterThan)(0)));
        this.value = upath_1.default.normalize(value);
    }
    join(another) {
        return new Path(upath_1.default.join(this.value, another.value));
    }
    split() {
        return this.value
            .split(Path.Separator)
            .filter(segment => !!segment); // so that we ignore the trailing path separator in absolute paths
    }
    resolve(another) {
        return new Path(upath_1.default.resolve(this.value, another.value));
    }
    relative(another) {
        return new Path(upath_1.default.relative(this.value, another.value) || '.');
    }
    directory() {
        return new Path(upath_1.default.dirname(this.value));
    }
    basename() {
        return upath_1.default.basename(this.value);
    }
    isAbsolute() {
        return upath_1.default.isAbsolute(this.value);
    }
    root() {
        return new Path(upath_1.default.parse(this.value).root);
    }
    toFileURL() {
        return new URL(encodeURI(`file://${this.value}`).replaceAll(/[#?]/g, encodeURIComponent));
    }
}
exports.Path = Path;
//# sourceMappingURL=Path.js.map