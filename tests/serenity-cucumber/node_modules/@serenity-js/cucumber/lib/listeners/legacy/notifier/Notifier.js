"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Notifier = void 0;
const events_1 = require("@serenity-js/core/lib/events");
const model_1 = require("@serenity-js/core/lib/model");
function notEmpty(list) {
    return list.filter(item => !!item);
}
/**
 * @private
 */
class Notifier {
    serenity;
    currentSceneId;
    currentScenario;
    currentStepActivityId;
    constructor(serenity) {
        this.serenity = serenity;
    }
    testRunStarts() {
        this.emit(new events_1.TestRunStarts(this.serenity.currentTime()));
    }
    outlineDetected(sceneId, scenario, outline, feature) {
        const outlineDetails = this.detailsOf(outline, feature), scenarioDetails = this.detailsOf(scenario, feature), template = outline.steps.map(step => step.name.value).join('\n');
        this.emit(...notEmpty([
            new events_1.SceneSequenceDetected(sceneId, outlineDetails, this.serenity.currentTime()),
            new events_1.SceneTemplateDetected(sceneId, new model_1.Description(template), this.serenity.currentTime()),
            new events_1.SceneParametersDetected(sceneId, scenarioDetails, outline.parameters[scenario.location.line], this.serenity.currentTime()),
        ]));
    }
    scenarioStarts(sceneId, scenario, feature) {
        this.currentSceneId = sceneId;
        const details = this.detailsOf(scenario, feature);
        this.currentScenario = details;
        // todo: emit SceneBackgroundDetected?
        this.emit(...notEmpty([
            new events_1.SceneStarts(this.currentSceneId, details, this.serenity.currentTime()),
            feature.description && new events_1.FeatureNarrativeDetected(this.currentSceneId, feature.description, this.serenity.currentTime()),
            new events_1.TestRunnerDetected(this.currentSceneId, new model_1.Name('JS'), this.serenity.currentTime()),
            ...this.scenarioHierarchyTagsFor(feature).map(tag => new events_1.SceneTagged(this.currentSceneId, tag, this.serenity.currentTime())),
            !!scenario.description && new events_1.SceneDescriptionDetected(this.currentSceneId, scenario.description, this.serenity.currentTime()),
            ...scenario.tags.map(tag => new events_1.SceneTagged(this.currentSceneId, tag, this.serenity.currentTime())),
        ]));
    }
    stepStarts(step) {
        const activityDetails = new model_1.ActivityDetails(step.name, step.location);
        this.currentStepActivityId = this.serenity.assignNewActivityId(activityDetails);
        this.emit(new events_1.TaskStarts(this.currentSceneId, this.currentStepActivityId, activityDetails, this.serenity.currentTime()));
    }
    stepFinished(step, outcome) {
        this.emit(new events_1.TaskFinished(this.currentSceneId, this.currentStepActivityId, new model_1.ActivityDetails(step.name, step.location), outcome, this.serenity.currentTime()));
    }
    scenarioFinishes() {
        this.emitSceneFinishes();
    }
    scenarioFinished(scenario, feature, outcome) {
        const details = this.detailsOf(scenario, feature);
        this.emit(new events_1.SceneFinished(this.currentSceneId, details, outcome, this.serenity.currentTime()));
    }
    testRunFinishes() {
        this.emit(new events_1.TestRunFinishes(this.serenity.currentTime()));
    }
    testRunFinished(outcome) {
        this.emit(new events_1.TestRunFinished(outcome, this.serenity.currentTime()));
    }
    emitSceneFinishes() {
        this.emit(new events_1.SceneFinishes(this.currentSceneId, this.serenity.currentTime()));
    }
    detailsOf(scenario, feature) {
        return new model_1.ScenarioDetails(scenario.name, new model_1.Category(feature.name.value), scenario.location);
    }
    scenarioHierarchyTagsFor(feature) {
        const directories = notEmpty(feature.location.path.directory().split()), featuresIndex = directories.indexOf('features'), hierarchy = [...directories.slice(featuresIndex + 1), feature.name.value];
        const [featureName, capabilityName, themeName] = hierarchy.reverse();
        return notEmpty([
            themeName && model_1.Tag.humanReadable(model_1.ThemeTag, themeName),
            capabilityName && model_1.Tag.humanReadable(model_1.CapabilityTag, capabilityName),
            feature && new model_1.FeatureTag(featureName),
        ]);
    }
    emit(...events) {
        events.forEach(event => this.serenity.announce(event));
    }
}
exports.Notifier = Notifier;
//# sourceMappingURL=Notifier.js.map