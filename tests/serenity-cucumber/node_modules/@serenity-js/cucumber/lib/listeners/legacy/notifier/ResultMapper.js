"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResultMapper = void 0;
const core_1 = require("@serenity-js/core");
const model_1 = require("@serenity-js/core/lib/model");
const errors_1 = require("../../../errors");
/**
 * @package
 */
class ResultMapper {
    serenity;
    constructor(serenity) {
        this.serenity = serenity;
    }
    outcomeFor(status, maybeError) {
        const error = this.errorFrom(maybeError);
        if (this.isTimeoutError(error)) {
            return new model_1.ExecutionFailedWithError(error);
        }
        switch (true) {
            case status === 'undefined':
                return new model_1.ImplementationPending(new core_1.ImplementationPendingError('Step not implemented'));
            case status === 'ambiguous':
                if (!error) {
                    // Only the step result contains the "ambiguous step def error", the scenario itself doesn't
                    return new model_1.ExecutionFailedWithError(new errors_1.AmbiguousStepDefinitionError('Multiple step definitions match'));
                }
                return new model_1.ExecutionFailedWithError(error);
            case status === 'failed':
                return this.problemIndicationOutcomeFromError(error);
            case status === 'pending':
                return new model_1.ImplementationPending(new core_1.ImplementationPendingError('Step not implemented'));
            case status === 'skipped':
                return new model_1.ExecutionSkipped();
            // case status === 'passed':
            default:
                return new model_1.ExecutionSuccessful();
        }
    }
    errorFrom(error) {
        switch (typeof error) {
            case 'string': return new Error(error);
            case 'object': return error;
            case 'function': return error;
            default: return void 0;
        }
    }
    isTimeoutError(error) {
        return error && /timed out/.test(error.message);
    }
    isANonSerenityAssertionError(error) {
        return error instanceof Error
            && error.name === 'AssertionError'
            && error.message && hasOwnProperty(error, 'expected')
            && hasOwnProperty(error, 'actual');
    }
    problemIndicationOutcomeFromError(error) {
        if (error instanceof core_1.AssertionError) {
            return new model_1.ExecutionFailedWithAssertionError(error);
        }
        if (this.isANonSerenityAssertionError(error)) {
            return new model_1.ExecutionFailedWithAssertionError(this.serenity.createError(core_1.AssertionError, {
                message: error.message,
                diff: {
                    expected: error.expected,
                    actual: error.actual,
                },
                cause: error,
            }));
        }
        if (error instanceof core_1.TestCompromisedError) {
            return new model_1.ExecutionCompromised(error);
        }
        return new model_1.ExecutionFailedWithError(error);
    }
}
exports.ResultMapper = ResultMapper;
/**
 * @private
 */
function hasOwnProperty(value, fieldName) {
    return Object.prototype.hasOwnProperty.call(value, fieldName);
}
//# sourceMappingURL=ResultMapper.js.map