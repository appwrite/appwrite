{"version":3,"file":"step_definition.js","sourceRoot":"","sources":["../../src/models/step_definition.ts"],"names":[],"mappings":";;;;;AAAA,8DAAoC;AACpC,8DAKqB;AACrB,sDAAqD;AAErD,oDAAgD;AAGhD,MAAqB,cAAe,SAAQ,oBAAU;IAKpD,YAAY,IAA+B;QACzC,KAAK,CAAC,IAAI,CAAC,CAAA;QACX,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAA;QAC3B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAA;QAC3B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAA;IACnC,CAAC;IAED,KAAK,CAAC,uBAAuB,CAAC,EAC5B,IAAI,EACJ,KAAK,GACqB;QAC1B,MAAM,UAAU,GAAG,MAAM,OAAO,CAAC,GAAG,CAClC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CACnE,CAAA;QACD,IAAI,IAAA,6BAAa,EAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YAChC,MAAM,iBAAiB,GAAG,IAAA,kCAAiB,EAAM,IAAI,CAAC,QAAQ,EAAE;gBAC9D,SAAS,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,oBAAS,CAAC,GAAG,CAAC;gBACtC,SAAS,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,OAAO;aAChC,CAAC,CAAA;YACF,UAAU,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAA;SACnC;QACD,OAAO;YACL,2BAA2B,EAAE,GAAG,EAAE,CAChC,IAAI,CAAC,+BAA+B,CAAC,UAAU,CAAC;YAClD,UAAU;YACV,gBAAgB,EAAE,CAAC,UAAU,CAAC,MAAM,EAAE,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC;SAC7D,CAAA;IACH,CAAC;IAED,eAAe,CAAC,QAAgB;QAC9B,OAAO,IAAA,6BAAa,EAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAA;IACvD,CAAC;CACF;AArCD,iCAqCC","sourcesContent":["import DataTable from './data_table'\nimport Definition, {\n  IDefinition,\n  IGetInvocationDataRequest,\n  IGetInvocationDataResponse,\n  IStepDefinitionParameters,\n} from './definition'\nimport { parseStepArgument } from '../step_arguments'\nimport { Expression } from '@cucumber/cucumber-expressions'\nimport { doesHaveValue } from '../value_checker'\nimport { GherkinStepKeyword } from './gherkin_step_keyword'\n\nexport default class StepDefinition extends Definition implements IDefinition {\n  public readonly keyword: GherkinStepKeyword\n  public readonly pattern: string | RegExp\n  public readonly expression: Expression\n\n  constructor(data: IStepDefinitionParameters) {\n    super(data)\n    this.keyword = data.keyword\n    this.pattern = data.pattern\n    this.expression = data.expression\n  }\n\n  async getInvocationParameters({\n    step,\n    world,\n  }: IGetInvocationDataRequest): Promise<IGetInvocationDataResponse> {\n    const parameters = await Promise.all(\n      this.expression.match(step.text).map((arg) => arg.getValue(world))\n    )\n    if (doesHaveValue(step.argument)) {\n      const argumentParamater = parseStepArgument<any>(step.argument, {\n        dataTable: (arg) => new DataTable(arg),\n        docString: (arg) => arg.content,\n      })\n      parameters.push(argumentParamater)\n    }\n    return {\n      getInvalidCodeLengthMessage: () =>\n        this.baseGetInvalidCodeLengthMessage(parameters),\n      parameters,\n      validCodeLengths: [parameters.length, parameters.length + 1],\n    }\n  }\n\n  matchesStepName(stepName: string): boolean {\n    return doesHaveValue(this.expression.match(stepName))\n  }\n}\n"]}