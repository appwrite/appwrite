{"version":3,"file":"data_table.js","sourceRoot":"","sources":["../../src/models/data_table.ts"],"names":[],"mappings":";;AAEA,MAAqB,SAAS;IAG5B,YAAY,WAA8C;QACxD,IAAI,WAAW,YAAY,KAAK,EAAE;YAChC,IAAI,CAAC,QAAQ,GAAG,WAAW,CAAA;SAC5B;aAAM;YACL,IAAI,CAAC,QAAQ,GAAG,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAC3C,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CACpC,CAAA;SACF;IACH,CAAC;IAED,MAAM;QACJ,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,CAAA;QACvB,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAA;QACpB,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;QACjC,OAAO,WAAW,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE;YAChC,MAAM,SAAS,GAA2B,EAAE,CAAA;YAC5C,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;YAC9D,OAAO,SAAS,CAAA;QAClB,CAAC,CAAC,CAAA;IACJ,CAAC;IAED,GAAG;QACD,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;IAC/B,CAAC;IAED,IAAI;QACF,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,CAAA;QACvB,IAAI,CAAC,KAAK,EAAE,CAAA;QACZ,OAAO,IAAI,CAAA;IACb,CAAC;IAED,QAAQ;QACN,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,CAAA;QACvB,MAAM,qBAAqB,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,MAAM,KAAK,CAAC,CAAC,CAAA;QACnE,IAAI,CAAC,qBAAqB,EAAE;YAC1B,MAAM,IAAI,KAAK,CACb,qFAAqF,CACtF,CAAA;SACF;QACD,MAAM,MAAM,GAA2B,EAAE,CAAA;QACzC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;QAC1C,OAAO,MAAM,CAAA;IACf,CAAC;IAED,SAAS;QACP,MAAM,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAC/C,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAC/B,CAAA;QACD,OAAO,IAAI,SAAS,CAAC,UAAU,CAAC,CAAA;IAClC,CAAC;CACF;AArDD,4BAqDC","sourcesContent":["import * as messages from '@cucumber/messages'\n\nexport default class DataTable {\n  private readonly rawTable: string[][]\n\n  constructor(sourceTable: messages.PickleTable | string[][]) {\n    if (sourceTable instanceof Array) {\n      this.rawTable = sourceTable\n    } else {\n      this.rawTable = sourceTable.rows.map((row) =>\n        row.cells.map((cell) => cell.value)\n      )\n    }\n  }\n\n  hashes(): Record<string, string>[] {\n    const copy = this.raw()\n    const keys = copy[0]\n    const valuesArray = copy.slice(1)\n    return valuesArray.map((values) => {\n      const rowObject: Record<string, string> = {}\n      keys.forEach((key, index) => (rowObject[key] = values[index]))\n      return rowObject\n    })\n  }\n\n  raw(): string[][] {\n    return this.rawTable.slice(0)\n  }\n\n  rows(): string[][] {\n    const copy = this.raw()\n    copy.shift()\n    return copy\n  }\n\n  rowsHash(): Record<string, string> {\n    const rows = this.raw()\n    const everyRowHasTwoColumns = rows.every((row) => row.length === 2)\n    if (!everyRowHasTwoColumns) {\n      throw new Error(\n        'rowsHash can only be called on a data table where all rows have exactly two columns'\n      )\n    }\n    const result: Record<string, string> = {}\n    rows.forEach((x) => (result[x[0]] = x[1]))\n    return result\n  }\n\n  transpose(): DataTable {\n    const transposed = this.rawTable[0].map((x, i) =>\n      this.rawTable.map((y) => y[i])\n    )\n    return new DataTable(transposed)\n  }\n}\n"]}