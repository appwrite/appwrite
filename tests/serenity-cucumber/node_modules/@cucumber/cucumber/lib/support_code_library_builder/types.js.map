{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/support_code_library_builder/types.ts"],"names":[],"mappings":"","sourcesContent":["import * as messages from '@cucumber/messages'\nimport TestCaseHookDefinition from '../models/test_case_hook_definition'\nimport TestStepHookDefinition from '../models/test_step_hook_definition'\nimport TestRunHookDefinition from '../models/test_run_hook_definition'\nimport StepDefinition from '../models/step_definition'\nimport { IWorld } from './world'\nimport { SourcedParameterTypeRegistry } from './sourced_parameter_type_registry'\n\nexport type DefineStepPattern = string | RegExp\nexport type ParallelAssignmentValidator = (\n  pickle: messages.Pickle,\n  runningPickles: messages.Pickle[]\n) => boolean\nexport interface ITestCaseHookParameter {\n  gherkinDocument: messages.GherkinDocument\n  pickle: messages.Pickle\n  result?: messages.TestStepResult\n  willBeRetried?: boolean\n  testCaseStartedId: string\n}\n\nexport interface ITestStepHookParameter {\n  gherkinDocument: messages.GherkinDocument\n  pickle: messages.Pickle\n  pickleStep: messages.PickleStep\n  result: messages.TestStepResult\n  testCaseStartedId: string\n  testStepId: string\n}\n\nexport type TestCaseHookFunction<WorldType> = (\n  this: WorldType,\n  arg: ITestCaseHookParameter\n) => any | Promise<any>\n\nexport type TestStepHookFunction<WorldType> = (\n  this: WorldType,\n  arg: ITestStepHookParameter\n) => any | Promise<any>\n\nexport type TestStepFunction<WorldType> = (\n  this: WorldType,\n  ...args: any[]\n) => any | Promise<any>\n\nexport interface IDefineStepOptions {\n  timeout?: number\n  wrapperOptions?: any\n}\n\nexport interface IDefineTestCaseHookOptions {\n  name?: string\n  tags?: string\n  timeout?: number\n}\n\nexport interface IDefineTestStepHookOptions {\n  tags?: string\n  timeout?: number\n}\n\nexport interface IDefineTestRunHookOptions {\n  timeout?: number\n}\n\nexport interface IParameterTypeDefinition<T> {\n  name: string\n  regexp: readonly RegExp[] | readonly string[] | RegExp | string\n  transformer: (...match: string[]) => T\n  useForSnippets?: boolean\n  preferForRegexpMatch?: boolean\n}\n\nexport type IDefineStep = (<WorldType = IWorld>(\n  pattern: DefineStepPattern,\n  code: TestStepFunction<WorldType>\n) => void) &\n  (<WorldType = IWorld>(\n    pattern: DefineStepPattern,\n    options: IDefineStepOptions,\n    code: TestStepFunction<WorldType>\n  ) => void)\n\nexport interface IDefineSupportCodeMethods {\n  defineParameterType: (options: IParameterTypeDefinition<any>) => void\n  defineStep: IDefineStep\n  setDefaultTimeout: (milliseconds: number) => void\n  setDefinitionFunctionWrapper: (fn: Function) => void\n  setParallelCanAssign: (fn: ParallelAssignmentValidator) => void\n  setWorldConstructor: (fn: any) => void\n  After: (<WorldType = IWorld>(code: TestCaseHookFunction<WorldType>) => void) &\n    (<WorldType = IWorld>(\n      tags: string,\n      code: TestCaseHookFunction<WorldType>\n    ) => void) &\n    (<WorldType = IWorld>(\n      options: IDefineTestCaseHookOptions,\n      code: TestCaseHookFunction<WorldType>\n    ) => void)\n  AfterStep: (<WorldType = IWorld>(\n    code: TestStepHookFunction<WorldType>\n  ) => void) &\n    (<WorldType = IWorld>(\n      tags: string,\n      code: TestStepHookFunction<WorldType>\n    ) => void) &\n    (<WorldType = IWorld>(\n      options: IDefineTestStepHookOptions,\n      code: TestStepHookFunction<WorldType>\n    ) => void)\n  AfterAll: ((code: Function) => void) &\n    ((options: IDefineTestRunHookOptions, code: Function) => void)\n  Before: (<WorldType = IWorld>(\n    code: TestCaseHookFunction<WorldType>\n  ) => void) &\n    (<WorldType = IWorld>(\n      tags: string,\n      code: TestCaseHookFunction<WorldType>\n    ) => void) &\n    (<WorldType = IWorld>(\n      options: IDefineTestCaseHookOptions,\n      code: TestCaseHookFunction<WorldType>\n    ) => void)\n  BeforeStep: (<WorldType = IWorld>(\n    code: TestStepHookFunction<WorldType>\n  ) => void) &\n    (<WorldType = IWorld>(\n      tags: string,\n      code: TestStepHookFunction<WorldType>\n    ) => void) &\n    (<WorldType = IWorld>(\n      options: IDefineTestStepHookOptions,\n      code: TestStepHookFunction<WorldType>\n    ) => void)\n  BeforeAll: ((code: Function) => void) &\n    ((options: IDefineTestRunHookOptions, code: Function) => void)\n  Given: IDefineStep\n  Then: IDefineStep\n  When: IDefineStep\n}\n\nexport interface ISupportCodeCoordinates {\n  requireModules: string[]\n  requirePaths: string[]\n  importPaths: string[]\n}\n\nexport interface ISupportCodeLibrary {\n  readonly originalCoordinates: ISupportCodeCoordinates\n  readonly afterTestCaseHookDefinitions: TestCaseHookDefinition[]\n  readonly afterTestStepHookDefinitions: TestStepHookDefinition[]\n  readonly afterTestRunHookDefinitions: TestRunHookDefinition[]\n  readonly beforeTestCaseHookDefinitions: TestCaseHookDefinition[]\n  readonly beforeTestStepHookDefinitions: TestStepHookDefinition[]\n  readonly beforeTestRunHookDefinitions: TestRunHookDefinition[]\n  readonly defaultTimeout: number\n  readonly stepDefinitions: StepDefinition[]\n  readonly undefinedParameterTypes: messages.UndefinedParameterType[]\n  readonly parameterTypeRegistry: SourcedParameterTypeRegistry\n  readonly World: any\n  readonly parallelCanAssign: ParallelAssignmentValidator\n}\n"]}