"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.source = void 0;
exports.source = "var pwExport =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/server/supplements/injected/recorder.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/server/common/cssParser.ts\":\n/*!****************************************!*\\\n  !*** ./src/server/common/cssParser.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serializeSelector = exports.parseCSS = void 0;\nconst css = __importStar(__webpack_require__(/*! ./cssTokenizer */ \"./src/server/common/cssTokenizer.js\"));\nfunction parseCSS(selector, customNames) {\n    let tokens;\n    try {\n        tokens = css.tokenize(selector);\n        if (!(tokens[tokens.length - 1] instanceof css.EOFToken))\n            tokens.push(new css.EOFToken());\n    }\n    catch (e) {\n        const newMessage = e.message + ` while parsing selector \"${selector}\"`;\n        const index = (e.stack || '').indexOf(e.message);\n        if (index !== -1)\n            e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n        e.message = newMessage;\n        throw e;\n    }\n    const unsupportedToken = tokens.find(token => {\n        return (token instanceof css.AtKeywordToken) ||\n            (token instanceof css.BadStringToken) ||\n            (token instanceof css.BadURLToken) ||\n            (token instanceof css.ColumnToken) ||\n            (token instanceof css.CDOToken) ||\n            (token instanceof css.CDCToken) ||\n            (token instanceof css.SemicolonToken) ||\n            // TODO: Consider using these for something, e.g. to escape complex strings.\n            // For example :xpath{ (//div/bar[@attr=\"foo\"])[2]/baz }\n            // Or this way :xpath( {complex-xpath-goes-here(\"hello\")} )\n            (token instanceof css.OpenCurlyToken) ||\n            (token instanceof css.CloseCurlyToken) ||\n            // TODO: Consider treating these as strings?\n            (token instanceof css.URLToken) ||\n            (token instanceof css.PercentageToken);\n    });\n    if (unsupportedToken)\n        throw new Error(`Unsupported token \"${unsupportedToken.toSource()}\" while parsing selector \"${selector}\"`);\n    let pos = 0;\n    const names = new Set();\n    function unexpected() {\n        return new Error(`Unexpected token \"${tokens[pos].toSource()}\" while parsing selector \"${selector}\"`);\n    }\n    function skipWhitespace() {\n        while (tokens[pos] instanceof css.WhitespaceToken)\n            pos++;\n    }\n    function isIdent(p = pos) {\n        return tokens[p] instanceof css.IdentToken;\n    }\n    function isString(p = pos) {\n        return tokens[p] instanceof css.StringToken;\n    }\n    function isNumber(p = pos) {\n        return tokens[p] instanceof css.NumberToken;\n    }\n    function isComma(p = pos) {\n        return tokens[p] instanceof css.CommaToken;\n    }\n    function isCloseParen(p = pos) {\n        return tokens[p] instanceof css.CloseParenToken;\n    }\n    function isStar(p = pos) {\n        return (tokens[p] instanceof css.DelimToken) && tokens[p].value === '*';\n    }\n    function isEOF(p = pos) {\n        return tokens[p] instanceof css.EOFToken;\n    }\n    function isClauseCombinator(p = pos) {\n        return (tokens[p] instanceof css.DelimToken) && (['>', '+', '~'].includes(tokens[p].value));\n    }\n    function isSelectorClauseEnd(p = pos) {\n        return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || (tokens[p] instanceof css.WhitespaceToken);\n    }\n    function consumeFunctionArguments() {\n        const result = [consumeArgument()];\n        while (true) {\n            skipWhitespace();\n            if (!isComma())\n                break;\n            pos++;\n            result.push(consumeArgument());\n        }\n        return result;\n    }\n    function consumeArgument() {\n        skipWhitespace();\n        if (isNumber())\n            return tokens[pos++].value;\n        if (isString())\n            return tokens[pos++].value;\n        return consumeComplexSelector();\n    }\n    function consumeComplexSelector() {\n        skipWhitespace();\n        const result = { simples: [{ selector: consumeSimpleSelector(), combinator: '' }] };\n        while (true) {\n            skipWhitespace();\n            if (isClauseCombinator()) {\n                result.simples[result.simples.length - 1].combinator = tokens[pos++].value;\n                skipWhitespace();\n            }\n            else if (isSelectorClauseEnd()) {\n                break;\n            }\n            result.simples.push({ combinator: '', selector: consumeSimpleSelector() });\n        }\n        return result;\n    }\n    function consumeSimpleSelector() {\n        let rawCSSString = '';\n        const functions = [];\n        while (!isSelectorClauseEnd()) {\n            if (isIdent() || isStar()) {\n                rawCSSString += tokens[pos++].toSource();\n            }\n            else if (tokens[pos] instanceof css.HashToken) {\n                rawCSSString += tokens[pos++].toSource();\n            }\n            else if ((tokens[pos] instanceof css.DelimToken) && tokens[pos].value === '.') {\n                pos++;\n                if (isIdent())\n                    rawCSSString += '.' + tokens[pos++].toSource();\n                else\n                    throw unexpected();\n            }\n            else if (tokens[pos] instanceof css.ColonToken) {\n                pos++;\n                if (isIdent()) {\n                    if (!customNames.has(tokens[pos].value.toLowerCase())) {\n                        rawCSSString += ':' + tokens[pos++].toSource();\n                    }\n                    else {\n                        const name = tokens[pos++].value.toLowerCase();\n                        functions.push({ name, args: [] });\n                        names.add(name);\n                    }\n                }\n                else if (tokens[pos] instanceof css.FunctionToken) {\n                    const name = tokens[pos++].value.toLowerCase();\n                    if (!customNames.has(name)) {\n                        rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n                    }\n                    else {\n                        functions.push({ name, args: consumeFunctionArguments() });\n                        names.add(name);\n                    }\n                    skipWhitespace();\n                    if (!isCloseParen())\n                        throw unexpected();\n                    pos++;\n                }\n                else {\n                    throw unexpected();\n                }\n            }\n            else if (tokens[pos] instanceof css.OpenSquareToken) {\n                rawCSSString += '[';\n                pos++;\n                while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF())\n                    rawCSSString += tokens[pos++].toSource();\n                if (!(tokens[pos] instanceof css.CloseSquareToken))\n                    throw unexpected();\n                rawCSSString += ']';\n                pos++;\n            }\n            else {\n                throw unexpected();\n            }\n        }\n        if (!rawCSSString && !functions.length)\n            throw unexpected();\n        return { css: rawCSSString || undefined, functions };\n    }\n    function consumeBuiltinFunctionArguments() {\n        let s = '';\n        while (!isCloseParen() && !isEOF())\n            s += tokens[pos++].toSource();\n        return s;\n    }\n    const result = consumeFunctionArguments();\n    if (!isEOF())\n        throw new Error(`Error while parsing selector \"${selector}\"`);\n    if (result.some(arg => typeof arg !== 'object' || !('simples' in arg)))\n        throw new Error(`Error while parsing selector \"${selector}\"`);\n    return { selector: result, names: Array.from(names) };\n}\nexports.parseCSS = parseCSS;\nfunction serializeSelector(args) {\n    return args.map(arg => {\n        if (typeof arg === 'string')\n            return `\"${arg}\"`;\n        if (typeof arg === 'number')\n            return String(arg);\n        return arg.simples.map(({ selector, combinator }) => {\n            let s = selector.css || '';\n            s = s + selector.functions.map(func => `:${func.name}(${serializeSelector(func.args)})`).join('');\n            if (combinator)\n                s += ' ' + combinator;\n            return s;\n        }).join(' ');\n    }).join(', ');\n}\nexports.serializeSelector = serializeSelector;\n\n\n/***/ }),\n\n/***/ \"./src/server/common/cssTokenizer.js\":\n/*!*******************************************!*\\\n  !*** ./src/server/common/cssTokenizer.js ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/*\n * Original at https://github.com/tabatkins/parse-css\n * licensed under http://creativecommons.org/publicdomain/zero/1.0/\n *\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Changes from https://github.com/tabatkins/parse-css\n//   - Tabs are replaced with two spaces.\n//   - Everything not related to tokenizing - below the first exports block - is removed.\n// @ts-nocheck\n(function (root, factory) {\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    else {}\n}(this, function (exports) {\n    var between = function (num, first, last) { return num >= first && num <= last; };\n    function digit(code) { return between(code, 0x30, 0x39); }\n    function hexdigit(code) { return digit(code) || between(code, 0x41, 0x46) || between(code, 0x61, 0x66); }\n    function uppercaseletter(code) { return between(code, 0x41, 0x5a); }\n    function lowercaseletter(code) { return between(code, 0x61, 0x7a); }\n    function letter(code) { return uppercaseletter(code) || lowercaseletter(code); }\n    function nonascii(code) { return code >= 0x80; }\n    function namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }\n    function namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }\n    function nonprintable(code) { return between(code, 0, 8) || code == 0xb || between(code, 0xe, 0x1f) || code == 0x7f; }\n    function newline(code) { return code == 0xa; }\n    function whitespace(code) { return newline(code) || code == 9 || code == 0x20; }\n    function badescape(code) { return newline(code) || isNaN(code); }\n    var maximumallowedcodepoint = 0x10ffff;\n    var InvalidCharacterError = function (message) {\n        this.message = message;\n    };\n    InvalidCharacterError.prototype = new Error;\n    InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n    function preprocess(str) {\n        // Turn a string into an array of code points,\n        // following the preprocessing cleanup rules.\n        var codepoints = [];\n        for (var i = 0; i < str.length; i++) {\n            var code = str.charCodeAt(i);\n            if (code == 0xd && str.charCodeAt(i + 1) == 0xa) {\n                code = 0xa;\n                i++;\n            }\n            if (code == 0xd || code == 0xc)\n                code = 0xa;\n            if (code == 0x0)\n                code = 0xfffd;\n            if (between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i + 1), 0xdc00, 0xdfff)) {\n                // Decode a surrogate pair into an astral codepoint.\n                var lead = code - 0xd800;\n                var trail = str.charCodeAt(i + 1) - 0xdc00;\n                code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n                i++;\n            }\n            codepoints.push(code);\n        }\n        return codepoints;\n    }\n    function stringFromCode(code) {\n        if (code <= 0xffff)\n            return String.fromCharCode(code);\n        // Otherwise, encode astral char as surrogate pair.\n        code -= Math.pow(2, 16);\n        var lead = Math.floor(code / Math.pow(2, 10)) + 0xd800;\n        var trail = code % Math.pow(2, 10) + 0xdc00;\n        return String.fromCharCode(lead) + String.fromCharCode(trail);\n    }\n    function tokenize(str) {\n        str = preprocess(str);\n        var i = -1;\n        var tokens = [];\n        var code;\n        // Line number information.\n        var line = 0;\n        var column = 0;\n        // The only use of lastLineLength is in reconsume().\n        var lastLineLength = 0;\n        var incrLineno = function () {\n            line += 1;\n            lastLineLength = column;\n            column = 0;\n        };\n        var locStart = { line: line, column: column };\n        var codepoint = function (i) {\n            if (i >= str.length) {\n                return -1;\n            }\n            return str[i];\n        };\n        var next = function (num) {\n            if (num === undefined)\n                num = 1;\n            if (num > 3)\n                throw \"Spec Error: no more than three codepoints of lookahead.\";\n            return codepoint(i + num);\n        };\n        var consume = function (num) {\n            if (num === undefined)\n                num = 1;\n            i += num;\n            code = codepoint(i);\n            if (newline(code))\n                incrLineno();\n            else\n                column += num;\n            //console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));\n            return true;\n        };\n        var reconsume = function () {\n            i -= 1;\n            if (newline(code)) {\n                line -= 1;\n                column = lastLineLength;\n            }\n            else {\n                column -= 1;\n            }\n            locStart.line = line;\n            locStart.column = column;\n            return true;\n        };\n        var eof = function (codepoint) {\n            if (codepoint === undefined)\n                codepoint = code;\n            return codepoint == -1;\n        };\n        var donothing = function () { };\n        var parseerror = function () { console.log(\"Parse error at index \" + i + \", processing codepoint 0x\" + code.toString(16) + \".\"); return true; };\n        var consumeAToken = function () {\n            consumeComments();\n            consume();\n            if (whitespace(code)) {\n                while (whitespace(next()))\n                    consume();\n                return new WhitespaceToken;\n            }\n            else if (code == 0x22)\n                return consumeAStringToken();\n            else if (code == 0x23) {\n                if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n                    var token = new HashToken();\n                    if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n                        token.type = \"id\";\n                    token.value = consumeAName();\n                    return token;\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x24) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new SuffixMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x27)\n                return consumeAStringToken();\n            else if (code == 0x28)\n                return new OpenParenToken();\n            else if (code == 0x29)\n                return new CloseParenToken();\n            else if (code == 0x2a) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new SubstringMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x2b) {\n                if (startsWithANumber()) {\n                    reconsume();\n                    return consumeANumericToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x2c)\n                return new CommaToken();\n            else if (code == 0x2d) {\n                if (startsWithANumber()) {\n                    reconsume();\n                    return consumeANumericToken();\n                }\n                else if (next(1) == 0x2d && next(2) == 0x3e) {\n                    consume(2);\n                    return new CDCToken();\n                }\n                else if (startsWithAnIdentifier()) {\n                    reconsume();\n                    return consumeAnIdentlikeToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x2e) {\n                if (startsWithANumber()) {\n                    reconsume();\n                    return consumeANumericToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x3a)\n                return new ColonToken;\n            else if (code == 0x3b)\n                return new SemicolonToken;\n            else if (code == 0x3c) {\n                if (next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {\n                    consume(3);\n                    return new CDOToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x40) {\n                if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n                    return new AtKeywordToken(consumeAName());\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x5b)\n                return new OpenSquareToken();\n            else if (code == 0x5c) {\n                if (startsWithAValidEscape()) {\n                    reconsume();\n                    return consumeAnIdentlikeToken();\n                }\n                else {\n                    parseerror();\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x5d)\n                return new CloseSquareToken();\n            else if (code == 0x5e) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new PrefixMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x7b)\n                return new OpenCurlyToken();\n            else if (code == 0x7c) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new DashMatchToken();\n                }\n                else if (next() == 0x7c) {\n                    consume();\n                    return new ColumnToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (code == 0x7d)\n                return new CloseCurlyToken();\n            else if (code == 0x7e) {\n                if (next() == 0x3d) {\n                    consume();\n                    return new IncludeMatchToken();\n                }\n                else {\n                    return new DelimToken(code);\n                }\n            }\n            else if (digit(code)) {\n                reconsume();\n                return consumeANumericToken();\n            }\n            else if (namestartchar(code)) {\n                reconsume();\n                return consumeAnIdentlikeToken();\n            }\n            else if (eof())\n                return new EOFToken();\n            else\n                return new DelimToken(code);\n        };\n        var consumeComments = function () {\n            while (next(1) == 0x2f && next(2) == 0x2a) {\n                consume(2);\n                while (true) {\n                    consume();\n                    if (code == 0x2a && next() == 0x2f) {\n                        consume();\n                        break;\n                    }\n                    else if (eof()) {\n                        parseerror();\n                        return;\n                    }\n                }\n            }\n        };\n        var consumeANumericToken = function () {\n            var num = consumeANumber();\n            if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n                var token = new DimensionToken();\n                token.value = num.value;\n                token.repr = num.repr;\n                token.type = num.type;\n                token.unit = consumeAName();\n                return token;\n            }\n            else if (next() == 0x25) {\n                consume();\n                var token = new PercentageToken();\n                token.value = num.value;\n                token.repr = num.repr;\n                return token;\n            }\n            else {\n                var token = new NumberToken();\n                token.value = num.value;\n                token.repr = num.repr;\n                token.type = num.type;\n                return token;\n            }\n        };\n        var consumeAnIdentlikeToken = function () {\n            var str = consumeAName();\n            if (str.toLowerCase() == \"url\" && next() == 0x28) {\n                consume();\n                while (whitespace(next(1)) && whitespace(next(2)))\n                    consume();\n                if (next() == 0x22 || next() == 0x27) {\n                    return new FunctionToken(str);\n                }\n                else if (whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {\n                    return new FunctionToken(str);\n                }\n                else {\n                    return consumeAURLToken();\n                }\n            }\n            else if (next() == 0x28) {\n                consume();\n                return new FunctionToken(str);\n            }\n            else {\n                return new IdentToken(str);\n            }\n        };\n        var consumeAStringToken = function (endingCodePoint) {\n            if (endingCodePoint === undefined)\n                endingCodePoint = code;\n            var string = \"\";\n            while (consume()) {\n                if (code == endingCodePoint || eof()) {\n                    return new StringToken(string);\n                }\n                else if (newline(code)) {\n                    parseerror();\n                    reconsume();\n                    return new BadStringToken();\n                }\n                else if (code == 0x5c) {\n                    if (eof(next())) {\n                        donothing();\n                    }\n                    else if (newline(next())) {\n                        consume();\n                    }\n                    else {\n                        string += stringFromCode(consumeEscape());\n                    }\n                }\n                else {\n                    string += stringFromCode(code);\n                }\n            }\n        };\n        var consumeAURLToken = function () {\n            var token = new URLToken(\"\");\n            while (whitespace(next()))\n                consume();\n            if (eof(next()))\n                return token;\n            while (consume()) {\n                if (code == 0x29 || eof()) {\n                    return token;\n                }\n                else if (whitespace(code)) {\n                    while (whitespace(next()))\n                        consume();\n                    if (next() == 0x29 || eof(next())) {\n                        consume();\n                        return token;\n                    }\n                    else {\n                        consumeTheRemnantsOfABadURL();\n                        return new BadURLToken();\n                    }\n                }\n                else if (code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {\n                    parseerror();\n                    consumeTheRemnantsOfABadURL();\n                    return new BadURLToken();\n                }\n                else if (code == 0x5c) {\n                    if (startsWithAValidEscape()) {\n                        token.value += stringFromCode(consumeEscape());\n                    }\n                    else {\n                        parseerror();\n                        consumeTheRemnantsOfABadURL();\n                        return new BadURLToken();\n                    }\n                }\n                else {\n                    token.value += stringFromCode(code);\n                }\n            }\n        };\n        var consumeEscape = function () {\n            // Assume the the current character is the \\\n            // and the next code point is not a newline.\n            consume();\n            if (hexdigit(code)) {\n                // Consume 1-6 hex digits\n                var digits = [code];\n                for (var total = 0; total < 5; total++) {\n                    if (hexdigit(next())) {\n                        consume();\n                        digits.push(code);\n                    }\n                    else {\n                        break;\n                    }\n                }\n                if (whitespace(next()))\n                    consume();\n                var value = parseInt(digits.map(function (x) { return String.fromCharCode(x); }).join(''), 16);\n                if (value > maximumallowedcodepoint)\n                    value = 0xfffd;\n                return value;\n            }\n            else if (eof()) {\n                return 0xfffd;\n            }\n            else {\n                return code;\n            }\n        };\n        var areAValidEscape = function (c1, c2) {\n            if (c1 != 0x5c)\n                return false;\n            if (newline(c2))\n                return false;\n            return true;\n        };\n        var startsWithAValidEscape = function () {\n            return areAValidEscape(code, next());\n        };\n        var wouldStartAnIdentifier = function (c1, c2, c3) {\n            if (c1 == 0x2d) {\n                return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);\n            }\n            else if (namestartchar(c1)) {\n                return true;\n            }\n            else if (c1 == 0x5c) {\n                return areAValidEscape(c1, c2);\n            }\n            else {\n                return false;\n            }\n        };\n        var startsWithAnIdentifier = function () {\n            return wouldStartAnIdentifier(code, next(1), next(2));\n        };\n        var wouldStartANumber = function (c1, c2, c3) {\n            if (c1 == 0x2b || c1 == 0x2d) {\n                if (digit(c2))\n                    return true;\n                if (c2 == 0x2e && digit(c3))\n                    return true;\n                return false;\n            }\n            else if (c1 == 0x2e) {\n                if (digit(c2))\n                    return true;\n                return false;\n            }\n            else if (digit(c1)) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        };\n        var startsWithANumber = function () {\n            return wouldStartANumber(code, next(1), next(2));\n        };\n        var consumeAName = function () {\n            var result = \"\";\n            while (consume()) {\n                if (namechar(code)) {\n                    result += stringFromCode(code);\n                }\n                else if (startsWithAValidEscape()) {\n                    result += stringFromCode(consumeEscape());\n                }\n                else {\n                    reconsume();\n                    return result;\n                }\n            }\n        };\n        var consumeANumber = function () {\n            var repr = [];\n            var type = \"integer\";\n            if (next() == 0x2b || next() == 0x2d) {\n                consume();\n                repr += stringFromCode(code);\n            }\n            while (digit(next())) {\n                consume();\n                repr += stringFromCode(code);\n            }\n            if (next(1) == 0x2e && digit(next(2))) {\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                type = \"number\";\n                while (digit(next())) {\n                    consume();\n                    repr += stringFromCode(code);\n                }\n            }\n            var c1 = next(1), c2 = next(2), c3 = next(3);\n            if ((c1 == 0x45 || c1 == 0x65) && digit(c2)) {\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                type = \"number\";\n                while (digit(next())) {\n                    consume();\n                    repr += stringFromCode(code);\n                }\n            }\n            else if ((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                consume();\n                repr += stringFromCode(code);\n                type = \"number\";\n                while (digit(next())) {\n                    consume();\n                    repr += stringFromCode(code);\n                }\n            }\n            var value = convertAStringToANumber(repr);\n            return { type: type, value: value, repr: repr };\n        };\n        var convertAStringToANumber = function (string) {\n            // CSS's number rules are identical to JS, afaik.\n            return +string;\n        };\n        var consumeTheRemnantsOfABadURL = function () {\n            while (consume()) {\n                if (code == 0x29 || eof()) {\n                    return;\n                }\n                else if (startsWithAValidEscape()) {\n                    consumeEscape();\n                    donothing();\n                }\n                else {\n                    donothing();\n                }\n            }\n        };\n        var iterationCount = 0;\n        while (!eof(next())) {\n            tokens.push(consumeAToken());\n            iterationCount++;\n            if (iterationCount > str.length * 2)\n                return \"I'm infinite-looping!\";\n        }\n        return tokens;\n    }\n    function CSSParserToken() { throw \"Abstract Base Class\"; }\n    CSSParserToken.prototype.toJSON = function () {\n        return { token: this.tokenType };\n    };\n    CSSParserToken.prototype.toString = function () { return this.tokenType; };\n    CSSParserToken.prototype.toSource = function () { return '' + this; };\n    function BadStringToken() { return this; }\n    BadStringToken.prototype = Object.create(CSSParserToken.prototype);\n    BadStringToken.prototype.tokenType = \"BADSTRING\";\n    function BadURLToken() { return this; }\n    BadURLToken.prototype = Object.create(CSSParserToken.prototype);\n    BadURLToken.prototype.tokenType = \"BADURL\";\n    function WhitespaceToken() { return this; }\n    WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);\n    WhitespaceToken.prototype.tokenType = \"WHITESPACE\";\n    WhitespaceToken.prototype.toString = function () { return \"WS\"; };\n    WhitespaceToken.prototype.toSource = function () { return \" \"; };\n    function CDOToken() { return this; }\n    CDOToken.prototype = Object.create(CSSParserToken.prototype);\n    CDOToken.prototype.tokenType = \"CDO\";\n    CDOToken.prototype.toSource = function () { return \"<!--\"; };\n    function CDCToken() { return this; }\n    CDCToken.prototype = Object.create(CSSParserToken.prototype);\n    CDCToken.prototype.tokenType = \"CDC\";\n    CDCToken.prototype.toSource = function () { return \"-->\"; };\n    function ColonToken() { return this; }\n    ColonToken.prototype = Object.create(CSSParserToken.prototype);\n    ColonToken.prototype.tokenType = \":\";\n    function SemicolonToken() { return this; }\n    SemicolonToken.prototype = Object.create(CSSParserToken.prototype);\n    SemicolonToken.prototype.tokenType = \";\";\n    function CommaToken() { return this; }\n    CommaToken.prototype = Object.create(CSSParserToken.prototype);\n    CommaToken.prototype.tokenType = \",\";\n    function GroupingToken() { throw \"Abstract Base Class\"; }\n    GroupingToken.prototype = Object.create(CSSParserToken.prototype);\n    function OpenCurlyToken() { this.value = \"{\"; this.mirror = \"}\"; return this; }\n    OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);\n    OpenCurlyToken.prototype.tokenType = \"{\";\n    function CloseCurlyToken() { this.value = \"}\"; this.mirror = \"{\"; return this; }\n    CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);\n    CloseCurlyToken.prototype.tokenType = \"}\";\n    function OpenSquareToken() { this.value = \"[\"; this.mirror = \"]\"; return this; }\n    OpenSquareToken.prototype = Object.create(GroupingToken.prototype);\n    OpenSquareToken.prototype.tokenType = \"[\";\n    function CloseSquareToken() { this.value = \"]\"; this.mirror = \"[\"; return this; }\n    CloseSquareToken.prototype = Object.create(GroupingToken.prototype);\n    CloseSquareToken.prototype.tokenType = \"]\";\n    function OpenParenToken() { this.value = \"(\"; this.mirror = \")\"; return this; }\n    OpenParenToken.prototype = Object.create(GroupingToken.prototype);\n    OpenParenToken.prototype.tokenType = \"(\";\n    function CloseParenToken() { this.value = \")\"; this.mirror = \"(\"; return this; }\n    CloseParenToken.prototype = Object.create(GroupingToken.prototype);\n    CloseParenToken.prototype.tokenType = \")\";\n    function IncludeMatchToken() { return this; }\n    IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    IncludeMatchToken.prototype.tokenType = \"~=\";\n    function DashMatchToken() { return this; }\n    DashMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    DashMatchToken.prototype.tokenType = \"|=\";\n    function PrefixMatchToken() { return this; }\n    PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    PrefixMatchToken.prototype.tokenType = \"^=\";\n    function SuffixMatchToken() { return this; }\n    SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    SuffixMatchToken.prototype.tokenType = \"$=\";\n    function SubstringMatchToken() { return this; }\n    SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    SubstringMatchToken.prototype.tokenType = \"*=\";\n    function ColumnToken() { return this; }\n    ColumnToken.prototype = Object.create(CSSParserToken.prototype);\n    ColumnToken.prototype.tokenType = \"||\";\n    function EOFToken() { return this; }\n    EOFToken.prototype = Object.create(CSSParserToken.prototype);\n    EOFToken.prototype.tokenType = \"EOF\";\n    EOFToken.prototype.toSource = function () { return \"\"; };\n    function DelimToken(code) {\n        this.value = stringFromCode(code);\n        return this;\n    }\n    DelimToken.prototype = Object.create(CSSParserToken.prototype);\n    DelimToken.prototype.tokenType = \"DELIM\";\n    DelimToken.prototype.toString = function () { return \"DELIM(\" + this.value + \")\"; };\n    DelimToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        return json;\n    };\n    DelimToken.prototype.toSource = function () {\n        if (this.value == \"\\\\\")\n            return \"\\\\\\n\";\n        else\n            return this.value;\n    };\n    function StringValuedToken() { throw \"Abstract Base Class\"; }\n    StringValuedToken.prototype = Object.create(CSSParserToken.prototype);\n    StringValuedToken.prototype.ASCIIMatch = function (str) {\n        return this.value.toLowerCase() == str.toLowerCase();\n    };\n    StringValuedToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        return json;\n    };\n    function IdentToken(val) {\n        this.value = val;\n    }\n    IdentToken.prototype = Object.create(StringValuedToken.prototype);\n    IdentToken.prototype.tokenType = \"IDENT\";\n    IdentToken.prototype.toString = function () { return \"IDENT(\" + this.value + \")\"; };\n    IdentToken.prototype.toSource = function () {\n        return escapeIdent(this.value);\n    };\n    function FunctionToken(val) {\n        this.value = val;\n        this.mirror = \")\";\n    }\n    FunctionToken.prototype = Object.create(StringValuedToken.prototype);\n    FunctionToken.prototype.tokenType = \"FUNCTION\";\n    FunctionToken.prototype.toString = function () { return \"FUNCTION(\" + this.value + \")\"; };\n    FunctionToken.prototype.toSource = function () {\n        return escapeIdent(this.value) + \"(\";\n    };\n    function AtKeywordToken(val) {\n        this.value = val;\n    }\n    AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);\n    AtKeywordToken.prototype.tokenType = \"AT-KEYWORD\";\n    AtKeywordToken.prototype.toString = function () { return \"AT(\" + this.value + \")\"; };\n    AtKeywordToken.prototype.toSource = function () {\n        return \"@\" + escapeIdent(this.value);\n    };\n    function HashToken(val) {\n        this.value = val;\n        this.type = \"unrestricted\";\n    }\n    HashToken.prototype = Object.create(StringValuedToken.prototype);\n    HashToken.prototype.tokenType = \"HASH\";\n    HashToken.prototype.toString = function () { return \"HASH(\" + this.value + \")\"; };\n    HashToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        return json;\n    };\n    HashToken.prototype.toSource = function () {\n        if (this.type == \"id\") {\n            return \"#\" + escapeIdent(this.value);\n        }\n        else {\n            return \"#\" + escapeHash(this.value);\n        }\n    };\n    function StringToken(val) {\n        this.value = val;\n    }\n    StringToken.prototype = Object.create(StringValuedToken.prototype);\n    StringToken.prototype.tokenType = \"STRING\";\n    StringToken.prototype.toString = function () {\n        return '\"' + escapeString(this.value) + '\"';\n    };\n    function URLToken(val) {\n        this.value = val;\n    }\n    URLToken.prototype = Object.create(StringValuedToken.prototype);\n    URLToken.prototype.tokenType = \"URL\";\n    URLToken.prototype.toString = function () { return \"URL(\" + this.value + \")\"; };\n    URLToken.prototype.toSource = function () {\n        return 'url(\"' + escapeString(this.value) + '\")';\n    };\n    function NumberToken() {\n        this.value = null;\n        this.type = \"integer\";\n        this.repr = \"\";\n    }\n    NumberToken.prototype = Object.create(CSSParserToken.prototype);\n    NumberToken.prototype.tokenType = \"NUMBER\";\n    NumberToken.prototype.toString = function () {\n        if (this.type == \"integer\")\n            return \"INT(\" + this.value + \")\";\n        return \"NUMBER(\" + this.value + \")\";\n    };\n    NumberToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        json.repr = this.repr;\n        return json;\n    };\n    NumberToken.prototype.toSource = function () { return this.repr; };\n    function PercentageToken() {\n        this.value = null;\n        this.repr = \"\";\n    }\n    PercentageToken.prototype = Object.create(CSSParserToken.prototype);\n    PercentageToken.prototype.tokenType = \"PERCENTAGE\";\n    PercentageToken.prototype.toString = function () { return \"PERCENTAGE(\" + this.value + \")\"; };\n    PercentageToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.repr = this.repr;\n        return json;\n    };\n    PercentageToken.prototype.toSource = function () { return this.repr + \"%\"; };\n    function DimensionToken() {\n        this.value = null;\n        this.type = \"integer\";\n        this.repr = \"\";\n        this.unit = \"\";\n    }\n    DimensionToken.prototype = Object.create(CSSParserToken.prototype);\n    DimensionToken.prototype.tokenType = \"DIMENSION\";\n    DimensionToken.prototype.toString = function () { return \"DIM(\" + this.value + \",\" + this.unit + \")\"; };\n    DimensionToken.prototype.toJSON = function () {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        json.repr = this.repr;\n        json.unit = this.unit;\n        return json;\n    };\n    DimensionToken.prototype.toSource = function () {\n        var source = this.repr;\n        var unit = escapeIdent(this.unit);\n        if (unit[0].toLowerCase() == \"e\" && (unit[1] == \"-\" || between(unit.charCodeAt(1), 0x30, 0x39))) {\n            // Unit is ambiguous with scinot\n            // Remove the leading \"e\", replace with escape.\n            unit = \"\\\\65 \" + unit.slice(1, unit.length);\n        }\n        return source + unit;\n    };\n    function escapeIdent(string) {\n        string = '' + string;\n        var result = '';\n        var firstcode = string.charCodeAt(0);\n        for (var i = 0; i < string.length; i++) {\n            var code = string.charCodeAt(i);\n            if (code == 0x0) {\n                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n            }\n            if (between(code, 0x1, 0x1f) || code == 0x7f ||\n                (i == 0 && between(code, 0x30, 0x39)) ||\n                (i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)) {\n                result += '\\\\' + code.toString(16) + ' ';\n            }\n            else if (code >= 0x80 ||\n                code == 0x2d ||\n                code == 0x5f ||\n                between(code, 0x30, 0x39) ||\n                between(code, 0x41, 0x5a) ||\n                between(code, 0x61, 0x7a)) {\n                result += string[i];\n            }\n            else {\n                result += '\\\\' + string[i];\n            }\n        }\n        return result;\n    }\n    function escapeHash(string) {\n        // Escapes the contents of \"unrestricted\"-type hash tokens.\n        // Won't preserve the ID-ness of \"id\"-type hash tokens;\n        // use escapeIdent() for that.\n        string = '' + string;\n        var result = '';\n        var firstcode = string.charCodeAt(0);\n        for (var i = 0; i < string.length; i++) {\n            var code = string.charCodeAt(i);\n            if (code == 0x0) {\n                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n            }\n            if (code >= 0x80 ||\n                code == 0x2d ||\n                code == 0x5f ||\n                between(code, 0x30, 0x39) ||\n                between(code, 0x41, 0x5a) ||\n                between(code, 0x61, 0x7a)) {\n                result += string[i];\n            }\n            else {\n                result += '\\\\' + code.toString(16) + ' ';\n            }\n        }\n        return result;\n    }\n    function escapeString(string) {\n        string = '' + string;\n        var result = '';\n        for (var i = 0; i < string.length; i++) {\n            var code = string.charCodeAt(i);\n            if (code == 0x0) {\n                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n            }\n            if (between(code, 0x1, 0x1f) || code == 0x7f) {\n                result += '\\\\' + code.toString(16) + ' ';\n            }\n            else if (code == 0x22 || code == 0x5c) {\n                result += '\\\\' + string[i];\n            }\n            else {\n                result += string[i];\n            }\n        }\n        return result;\n    }\n    // Exportation.\n    exports.tokenize = tokenize;\n    exports.IdentToken = IdentToken;\n    exports.FunctionToken = FunctionToken;\n    exports.AtKeywordToken = AtKeywordToken;\n    exports.HashToken = HashToken;\n    exports.StringToken = StringToken;\n    exports.BadStringToken = BadStringToken;\n    exports.URLToken = URLToken;\n    exports.BadURLToken = BadURLToken;\n    exports.DelimToken = DelimToken;\n    exports.NumberToken = NumberToken;\n    exports.PercentageToken = PercentageToken;\n    exports.DimensionToken = DimensionToken;\n    exports.IncludeMatchToken = IncludeMatchToken;\n    exports.DashMatchToken = DashMatchToken;\n    exports.PrefixMatchToken = PrefixMatchToken;\n    exports.SuffixMatchToken = SuffixMatchToken;\n    exports.SubstringMatchToken = SubstringMatchToken;\n    exports.ColumnToken = ColumnToken;\n    exports.WhitespaceToken = WhitespaceToken;\n    exports.CDOToken = CDOToken;\n    exports.CDCToken = CDCToken;\n    exports.ColonToken = ColonToken;\n    exports.SemicolonToken = SemicolonToken;\n    exports.CommaToken = CommaToken;\n    exports.OpenParenToken = OpenParenToken;\n    exports.CloseParenToken = CloseParenToken;\n    exports.OpenSquareToken = OpenSquareToken;\n    exports.CloseSquareToken = CloseSquareToken;\n    exports.OpenCurlyToken = OpenCurlyToken;\n    exports.CloseCurlyToken = CloseCurlyToken;\n    exports.EOFToken = EOFToken;\n    exports.CSSParserToken = CSSParserToken;\n    exports.GroupingToken = GroupingToken;\n}));\n\n\n/***/ }),\n\n/***/ \"./src/server/common/selectorParser.ts\":\n/*!*********************************************!*\\\n  !*** ./src/server/common/selectorParser.ts ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseSelector = exports.customCSSNames = void 0;\nconst cssParser_1 = __webpack_require__(/*! ./cssParser */ \"./src/server/common/cssParser.ts\");\nexports.customCSSNames = new Set(['not', 'is', 'where', 'has', 'scope', 'light', 'visible', 'text', 'text-matches', 'text-is', 'has-text', 'above', 'below', 'right-of', 'left-of', 'near', 'nth-match']);\nfunction parseSelector(selector) {\n    const result = parseSelectorV1(selector);\n    result.parts = result.parts.map(part => {\n        if (Array.isArray(part))\n            return part;\n        if (part.name === 'css' || part.name === 'css:light') {\n            if (part.name === 'css:light')\n                part.body = ':light(' + part.body + ')';\n            const parsedCSS = cssParser_1.parseCSS(part.body, exports.customCSSNames);\n            return parsedCSS.selector;\n        }\n        return part;\n    });\n    return {\n        parts: result.parts,\n        capture: result.capture,\n    };\n}\nexports.parseSelector = parseSelector;\nfunction parseSelectorV1(selector) {\n    let index = 0;\n    let quote;\n    let start = 0;\n    const result = { parts: [] };\n    const append = () => {\n        const part = selector.substring(start, index).trim();\n        const eqIndex = part.indexOf('=');\n        let name;\n        let body;\n        if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n            name = part.substring(0, eqIndex).trim();\n            body = part.substring(eqIndex + 1);\n        }\n        else if (part.length > 1 && part[0] === '\"' && part[part.length - 1] === '\"') {\n            name = 'text';\n            body = part;\n        }\n        else if (part.length > 1 && part[0] === \"'\" && part[part.length - 1] === \"'\") {\n            name = 'text';\n            body = part;\n        }\n        else if (/^\\(*\\/\\//.test(part) || part.startsWith('..')) {\n            // If selector starts with '//' or '//' prefixed with multiple opening\n            // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817\n            // If selector starts with '..', consider xpath as well.\n            name = 'xpath';\n            body = part;\n        }\n        else {\n            name = 'css';\n            body = part;\n        }\n        let capture = false;\n        if (name[0] === '*') {\n            capture = true;\n            name = name.substring(1);\n        }\n        result.parts.push({ name, body });\n        if (capture) {\n            if (result.capture !== undefined)\n                throw new Error(`Only one of the selectors can capture using * modifier`);\n            result.capture = result.parts.length - 1;\n        }\n    };\n    if (!selector.includes('>>')) {\n        index = selector.length;\n        append();\n        return result;\n    }\n    while (index < selector.length) {\n        const c = selector[index];\n        if (c === '\\\\' && index + 1 < selector.length) {\n            index += 2;\n        }\n        else if (c === quote) {\n            quote = undefined;\n            index++;\n        }\n        else if (!quote && (c === '\"' || c === '\\'' || c === '`')) {\n            quote = c;\n            index++;\n        }\n        else if (!quote && c === '>' && selector[index + 1] === '>') {\n            append();\n            index += 2;\n            start = index;\n        }\n        else {\n            index++;\n        }\n    }\n    append();\n    return result;\n}\n\n\n/***/ }),\n\n/***/ \"./src/server/injected/selectorEvaluator.ts\":\n/*!**************************************************!*\\\n  !*** ./src/server/injected/selectorEvaluator.ts ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isVisible = exports.parentElementOrShadowHost = exports.elementMatchesText = exports.elementText = exports.createRegexTextMatcher = exports.createStrictTextMatcher = exports.createLaxTextMatcher = exports.SelectorEvaluatorImpl = void 0;\nconst selectorParser_1 = __webpack_require__(/*! ../common/selectorParser */ \"./src/server/common/selectorParser.ts\");\nclass SelectorEvaluatorImpl {\n    constructor(extraEngines) {\n        this._engines = new Map();\n        this._cacheQueryCSS = new Map();\n        this._cacheMatches = new Map();\n        this._cacheQuery = new Map();\n        this._cacheMatchesSimple = new Map();\n        this._cacheMatchesParents = new Map();\n        this._cacheCallMatches = new Map();\n        this._cacheCallQuery = new Map();\n        this._cacheQuerySimple = new Map();\n        this._cacheText = new Map();\n        this._retainCacheCounter = 0;\n        for (const [name, engine] of extraEngines)\n            this._engines.set(name, engine);\n        this._engines.set('not', notEngine);\n        this._engines.set('is', isEngine);\n        this._engines.set('where', isEngine);\n        this._engines.set('has', hasEngine);\n        this._engines.set('scope', scopeEngine);\n        this._engines.set('light', lightEngine);\n        this._engines.set('visible', visibleEngine);\n        this._engines.set('text', textEngine);\n        this._engines.set('text-is', textIsEngine);\n        this._engines.set('text-matches', textMatchesEngine);\n        this._engines.set('has-text', hasTextEngine);\n        this._engines.set('right-of', createPositionEngine('right-of', boxRightOf));\n        this._engines.set('left-of', createPositionEngine('left-of', boxLeftOf));\n        this._engines.set('above', createPositionEngine('above', boxAbove));\n        this._engines.set('below', createPositionEngine('below', boxBelow));\n        this._engines.set('near', createPositionEngine('near', boxNear));\n        this._engines.set('nth-match', nthMatchEngine);\n        const allNames = [...this._engines.keys()];\n        allNames.sort();\n        const parserNames = [...selectorParser_1.customCSSNames];\n        parserNames.sort();\n        if (allNames.join('|') !== parserNames.join('|'))\n            throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${allNames.join('|')} vs ${parserNames.join('|')}`);\n    }\n    begin() {\n        ++this._retainCacheCounter;\n    }\n    end() {\n        --this._retainCacheCounter;\n        if (!this._retainCacheCounter) {\n            this._cacheQueryCSS.clear();\n            this._cacheMatches.clear();\n            this._cacheQuery.clear();\n            this._cacheMatchesSimple.clear();\n            this._cacheMatchesParents.clear();\n            this._cacheCallMatches.clear();\n            this._cacheCallQuery.clear();\n            this._cacheQuerySimple.clear();\n            this._cacheText.clear();\n        }\n    }\n    _cached(cache, main, rest, cb) {\n        if (!cache.has(main))\n            cache.set(main, []);\n        const entries = cache.get(main);\n        const entry = entries.find(e => rest.every((value, index) => e.rest[index] === value));\n        if (entry)\n            return entry.result;\n        const result = cb();\n        entries.push({ rest, result });\n        return result;\n    }\n    _checkSelector(s) {\n        const wellFormed = typeof s === 'object' && s &&\n            (Array.isArray(s) || ('simples' in s) && (s.simples.length));\n        if (!wellFormed)\n            throw new Error(`Malformed selector \"${s}\"`);\n        return s;\n    }\n    matches(element, s, context) {\n        const selector = this._checkSelector(s);\n        this.begin();\n        try {\n            return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow], () => {\n                if (Array.isArray(selector))\n                    return this._matchesEngine(isEngine, element, selector, context);\n                if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))\n                    return false;\n                return this._matchesParents(element, selector, selector.simples.length - 2, context);\n            });\n        }\n        finally {\n            this.end();\n        }\n    }\n    query(context, s) {\n        const selector = this._checkSelector(s);\n        this.begin();\n        try {\n            return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow], () => {\n                if (Array.isArray(selector))\n                    return this._queryEngine(isEngine, context, selector);\n                // query() recursively calls itself, so we set up a new map for this particular query() call.\n                const previousScoreMap = this._scoreMap;\n                this._scoreMap = new Map();\n                let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);\n                elements = elements.filter(element => this._matchesParents(element, selector, selector.simples.length - 2, context));\n                if (this._scoreMap.size) {\n                    elements.sort((a, b) => {\n                        const aScore = this._scoreMap.get(a);\n                        const bScore = this._scoreMap.get(b);\n                        if (aScore === bScore)\n                            return 0;\n                        if (aScore === undefined)\n                            return 1;\n                        if (bScore === undefined)\n                            return -1;\n                        return aScore - bScore;\n                    });\n                }\n                this._scoreMap = previousScoreMap;\n                return elements;\n            });\n        }\n        finally {\n            this.end();\n        }\n    }\n    _markScore(element, score) {\n        // HACK ALERT: temporary marks an element with a score, to be used\n        // for sorting at the end of the query().\n        if (this._scoreMap)\n            this._scoreMap.set(element, score);\n    }\n    _matchesSimple(element, simple, context) {\n        return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow], () => {\n            const isPossiblyScopeClause = simple.functions.some(f => f.name === 'scope' || f.name === 'is');\n            if (!isPossiblyScopeClause && element === context.scope)\n                return false;\n            if (simple.css && !this._matchesCSS(element, simple.css))\n                return false;\n            for (const func of simple.functions) {\n                if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))\n                    return false;\n            }\n            return true;\n        });\n    }\n    _querySimple(context, simple) {\n        if (!simple.functions.length)\n            return this._queryCSS(context, simple.css || '*');\n        return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow], () => {\n            let css = simple.css;\n            const funcs = simple.functions;\n            if (css === '*' && funcs.length)\n                css = undefined;\n            let elements;\n            let firstIndex = -1;\n            if (css !== undefined) {\n                elements = this._queryCSS(context, css);\n            }\n            else {\n                firstIndex = funcs.findIndex(func => this._getEngine(func.name).query !== undefined);\n                if (firstIndex === -1)\n                    firstIndex = 0;\n                elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);\n            }\n            for (let i = 0; i < funcs.length; i++) {\n                if (i === firstIndex)\n                    continue;\n                const engine = this._getEngine(funcs[i].name);\n                if (engine.matches !== undefined)\n                    elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));\n            }\n            for (let i = 0; i < funcs.length; i++) {\n                if (i === firstIndex)\n                    continue;\n                const engine = this._getEngine(funcs[i].name);\n                if (engine.matches === undefined)\n                    elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));\n            }\n            return elements;\n        });\n    }\n    _matchesParents(element, complex, index, context) {\n        if (index < 0)\n            return true;\n        return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow], () => {\n            const { selector: simple, combinator } = complex.simples[index];\n            if (combinator === '>') {\n                const parent = parentElementOrShadowHostInContext(element, context);\n                if (!parent || !this._matchesSimple(parent, simple, context))\n                    return false;\n                return this._matchesParents(parent, complex, index - 1, context);\n            }\n            if (combinator === '+') {\n                const previousSibling = previousSiblingInContext(element, context);\n                if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))\n                    return false;\n                return this._matchesParents(previousSibling, complex, index - 1, context);\n            }\n            if (combinator === '') {\n                let parent = parentElementOrShadowHostInContext(element, context);\n                while (parent) {\n                    if (this._matchesSimple(parent, simple, context)) {\n                        if (this._matchesParents(parent, complex, index - 1, context))\n                            return true;\n                        if (complex.simples[index - 1].combinator === '')\n                            break;\n                    }\n                    parent = parentElementOrShadowHostInContext(parent, context);\n                }\n                return false;\n            }\n            if (combinator === '~') {\n                let previousSibling = previousSiblingInContext(element, context);\n                while (previousSibling) {\n                    if (this._matchesSimple(previousSibling, simple, context)) {\n                        if (this._matchesParents(previousSibling, complex, index - 1, context))\n                            return true;\n                        if (complex.simples[index - 1].combinator === '~')\n                            break;\n                    }\n                    previousSibling = previousSiblingInContext(previousSibling, context);\n                }\n                return false;\n            }\n            if (combinator === '>=') {\n                let parent = element;\n                while (parent) {\n                    if (this._matchesSimple(parent, simple, context)) {\n                        if (this._matchesParents(parent, complex, index - 1, context))\n                            return true;\n                        if (complex.simples[index - 1].combinator === '')\n                            break;\n                    }\n                    parent = parentElementOrShadowHostInContext(parent, context);\n                }\n                return false;\n            }\n            throw new Error(`Unsupported combinator \"${combinator}\"`);\n        });\n    }\n    _matchesEngine(engine, element, args, context) {\n        if (engine.matches)\n            return this._callMatches(engine, element, args, context);\n        if (engine.query)\n            return this._callQuery(engine, args, context).includes(element);\n        throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n    }\n    _queryEngine(engine, context, args) {\n        if (engine.query)\n            return this._callQuery(engine, args, context);\n        if (engine.matches)\n            return this._queryCSS(context, '*').filter(element => this._callMatches(engine, element, args, context));\n        throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n    }\n    _callMatches(engine, element, args, context) {\n        return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, ...args], () => {\n            return engine.matches(element, args, context, this);\n        });\n    }\n    _callQuery(engine, args, context) {\n        return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, ...args], () => {\n            return engine.query(context, args, this);\n        });\n    }\n    _matchesCSS(element, css) {\n        return element.matches(css);\n    }\n    _queryCSS(context, css) {\n        return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow], () => {\n            let result = [];\n            function query(root) {\n                result = result.concat([...root.querySelectorAll(css)]);\n                if (!context.pierceShadow)\n                    return;\n                if (root.shadowRoot)\n                    query(root.shadowRoot);\n                for (const element of root.querySelectorAll('*')) {\n                    if (element.shadowRoot)\n                        query(element.shadowRoot);\n                }\n            }\n            query(context.scope);\n            return result;\n        });\n    }\n    _getEngine(name) {\n        const engine = this._engines.get(name);\n        if (!engine)\n            throw new Error(`Unknown selector engine \"${name}\"`);\n        return engine;\n    }\n}\nexports.SelectorEvaluatorImpl = SelectorEvaluatorImpl;\nconst isEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"is\" engine expects non-empty selector list`);\n        return args.some(selector => evaluator.matches(element, selector, context));\n    },\n    query(context, args, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"is\" engine expects non-empty selector list`);\n        let elements = [];\n        for (const arg of args)\n            elements = elements.concat(evaluator.query(context, arg));\n        return args.length === 1 ? elements : sortInDOMOrder(elements);\n    },\n};\nconst hasEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"has\" engine expects non-empty selector list`);\n        return evaluator.query({ ...context, scope: element }, args).length > 0;\n    },\n    // TODO: we do not implement \"relative selectors\", as in \"div:has(> span)\" or \"div:has(+ span)\".\n    // TODO: we can implement efficient \"query\" by matching \"args\" and returning\n    // all parents/descendants, just have to be careful with the \":scope\" matching.\n};\nconst scopeEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 0)\n            throw new Error(`\"scope\" engine expects no arguments`);\n        if (context.scope.nodeType === 9 /* Node.DOCUMENT_NODE */)\n            return element === context.scope.documentElement;\n        return element === context.scope;\n    },\n    query(context, args, evaluator) {\n        if (args.length !== 0)\n            throw new Error(`\"scope\" engine expects no arguments`);\n        if (context.scope.nodeType === 9 /* Node.DOCUMENT_NODE */) {\n            const root = context.scope.documentElement;\n            return root ? [root] : [];\n        }\n        if (context.scope.nodeType === 1 /* Node.ELEMENT_NODE */)\n            return [context.scope];\n        return [];\n    },\n};\nconst notEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0)\n            throw new Error(`\"not\" engine expects non-empty selector list`);\n        return !evaluator.matches(element, args, context);\n    },\n};\nconst lightEngine = {\n    query(context, args, evaluator) {\n        return evaluator.query({ ...context, pierceShadow: false }, args);\n    },\n    matches(element, args, context, evaluator) {\n        return evaluator.matches(element, args, { ...context, pierceShadow: false });\n    }\n};\nconst visibleEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length)\n            throw new Error(`\"visible\" engine expects no arguments`);\n        return isVisible(element);\n    }\n};\nconst textEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 1 || typeof args[0] !== 'string')\n            throw new Error(`\"text\" engine expects a single string`);\n        const matcher = createLaxTextMatcher(args[0]);\n        return elementMatchesText(evaluator, element, matcher) === 'self';\n    },\n};\nconst textIsEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 1 || typeof args[0] !== 'string')\n            throw new Error(`\"text-is\" engine expects a single string`);\n        const matcher = createStrictTextMatcher(args[0]);\n        return elementMatchesText(evaluator, element, matcher) !== 'none';\n    },\n};\nconst textMatchesEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length === 0 || typeof args[0] !== 'string' || args.length > 2 || (args.length === 2 && typeof args[1] !== 'string'))\n            throw new Error(`\"text-matches\" engine expects a regexp body and optional regexp flags`);\n        const matcher = createRegexTextMatcher(args[0], args.length === 2 ? args[1] : undefined);\n        return elementMatchesText(evaluator, element, matcher) === 'self';\n    },\n};\nconst hasTextEngine = {\n    matches(element, args, context, evaluator) {\n        if (args.length !== 1 || typeof args[0] !== 'string')\n            throw new Error(`\"has-text\" engine expects a single string`);\n        if (shouldSkipForTextMatching(element))\n            return false;\n        const matcher = createLaxTextMatcher(args[0]);\n        return matcher(elementText(evaluator, element));\n    },\n};\nfunction createLaxTextMatcher(text) {\n    text = text.trim().replace(/\\s+/g, ' ').toLowerCase();\n    return (elementText) => {\n        const s = elementText.full.trim().replace(/\\s+/g, ' ').toLowerCase();\n        return s.includes(text);\n    };\n}\nexports.createLaxTextMatcher = createLaxTextMatcher;\nfunction createStrictTextMatcher(text) {\n    text = text.trim().replace(/\\s+/g, ' ');\n    return (elementText) => {\n        return elementText.immediate.some(s => s.trim().replace(/\\s+/g, ' ') === text);\n    };\n}\nexports.createStrictTextMatcher = createStrictTextMatcher;\nfunction createRegexTextMatcher(source, flags) {\n    const re = new RegExp(source, flags);\n    return (elementText) => {\n        return re.test(elementText.full);\n    };\n}\nexports.createRegexTextMatcher = createRegexTextMatcher;\nfunction shouldSkipForTextMatching(element) {\n    return element.nodeName === 'SCRIPT' || element.nodeName === 'STYLE' || document.head && document.head.contains(element);\n}\nfunction elementText(evaluator, root) {\n    let value = evaluator._cacheText.get(root);\n    if (value === undefined) {\n        value = { full: '', immediate: [] };\n        if (!shouldSkipForTextMatching(root)) {\n            let currentImmediate = '';\n            if ((root instanceof HTMLInputElement) && (root.type === 'submit' || root.type === 'button')) {\n                value = { full: root.value, immediate: [root.value] };\n            }\n            else {\n                for (let child = root.firstChild; child; child = child.nextSibling) {\n                    if (child.nodeType === Node.TEXT_NODE) {\n                        value.full += child.nodeValue || '';\n                        currentImmediate += child.nodeValue || '';\n                    }\n                    else {\n                        if (currentImmediate)\n                            value.immediate.push(currentImmediate);\n                        currentImmediate = '';\n                        if (child.nodeType === Node.ELEMENT_NODE)\n                            value.full += elementText(evaluator, child).full;\n                    }\n                }\n                if (currentImmediate)\n                    value.immediate.push(currentImmediate);\n                if (root.shadowRoot)\n                    value.full += elementText(evaluator, root.shadowRoot).full;\n            }\n        }\n        evaluator._cacheText.set(root, value);\n    }\n    return value;\n}\nexports.elementText = elementText;\nfunction elementMatchesText(evaluator, element, matcher) {\n    if (shouldSkipForTextMatching(element))\n        return 'none';\n    if (!matcher(elementText(evaluator, element)))\n        return 'none';\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n        if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(evaluator, child)))\n            return 'selfAndChildren';\n    }\n    if (element.shadowRoot && matcher(elementText(evaluator, element.shadowRoot)))\n        return 'selfAndChildren';\n    return 'self';\n}\nexports.elementMatchesText = elementMatchesText;\nfunction boxRightOf(box1, box2, maxDistance) {\n    const distance = box1.left - box2.right;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxLeftOf(box1, box2, maxDistance) {\n    const distance = box2.left - box1.right;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxAbove(box1, box2, maxDistance) {\n    const distance = box2.top - box1.bottom;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxBelow(box1, box2, maxDistance) {\n    const distance = box1.top - box2.bottom;\n    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))\n        return;\n    return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxNear(box1, box2, maxDistance) {\n    const kThreshold = maxDistance === undefined ? 50 : maxDistance;\n    let score = 0;\n    if (box1.left - box2.right >= 0)\n        score += box1.left - box2.right;\n    if (box2.left - box1.right >= 0)\n        score += box2.left - box1.right;\n    if (box2.top - box1.bottom >= 0)\n        score += box2.top - box1.bottom;\n    if (box1.top - box2.bottom >= 0)\n        score += box1.top - box2.bottom;\n    return score > kThreshold ? undefined : score;\n}\nfunction createPositionEngine(name, scorer) {\n    return {\n        matches(element, args, context, evaluator) {\n            const maxDistance = args.length && typeof args[args.length - 1] === 'number' ? args[args.length - 1] : undefined;\n            const queryArgs = maxDistance === undefined ? args : args.slice(0, args.length - 1);\n            if (args.length < 1 + (maxDistance === undefined ? 0 : 1))\n                throw new Error(`\"${name}\" engine expects a selector list and optional maximum distance in pixels`);\n            const box = element.getBoundingClientRect();\n            let bestScore;\n            for (const e of evaluator.query(context, queryArgs)) {\n                if (e === element)\n                    continue;\n                const score = scorer(box, e.getBoundingClientRect(), maxDistance);\n                if (score === undefined)\n                    continue;\n                if (bestScore === undefined || score < bestScore)\n                    bestScore = score;\n            }\n            if (bestScore === undefined)\n                return false;\n            evaluator._markScore(element, bestScore);\n            return true;\n        }\n    };\n}\nconst nthMatchEngine = {\n    query(context, args, evaluator) {\n        let index = args[args.length - 1];\n        if (args.length < 2)\n            throw new Error(`\"nth-match\" engine expects non-empty selector list and an index argument`);\n        if (typeof index !== 'number' || index < 1)\n            throw new Error(`\"nth-match\" engine expects a one-based index as the last argument`);\n        const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);\n        index--; // one-based\n        return index < elements.length ? [elements[index]] : [];\n    },\n};\nfunction parentElementOrShadowHost(element) {\n    if (element.parentElement)\n        return element.parentElement;\n    if (!element.parentNode)\n        return;\n    if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n        return element.parentNode.host;\n}\nexports.parentElementOrShadowHost = parentElementOrShadowHost;\nfunction parentElementOrShadowHostInContext(element, context) {\n    if (element === context.scope)\n        return;\n    if (!context.pierceShadow)\n        return element.parentElement || undefined;\n    return parentElementOrShadowHost(element);\n}\nfunction previousSiblingInContext(element, context) {\n    if (element === context.scope)\n        return;\n    return element.previousElementSibling || undefined;\n}\nfunction isVisible(element) {\n    // Note: this logic should be similar to waitForDisplayedAtStablePosition() to avoid surprises.\n    if (!element.ownerDocument || !element.ownerDocument.defaultView)\n        return true;\n    const style = element.ownerDocument.defaultView.getComputedStyle(element);\n    if (!style || style.visibility === 'hidden')\n        return false;\n    const rect = element.getBoundingClientRect();\n    return rect.width > 0 && rect.height > 0;\n}\nexports.isVisible = isVisible;\nfunction sortInDOMOrder(elements) {\n    const elementToEntry = new Map();\n    const roots = [];\n    const result = [];\n    function append(element) {\n        let entry = elementToEntry.get(element);\n        if (entry)\n            return entry;\n        const parent = parentElementOrShadowHost(element);\n        if (parent) {\n            const parentEntry = append(parent);\n            parentEntry.children.push(element);\n        }\n        else {\n            roots.push(element);\n        }\n        entry = { children: [], taken: false };\n        elementToEntry.set(element, entry);\n        return entry;\n    }\n    elements.forEach(e => append(e).taken = true);\n    function visit(element) {\n        const entry = elementToEntry.get(element);\n        if (entry.taken)\n            result.push(element);\n        if (entry.children.length > 1) {\n            const set = new Set(entry.children);\n            entry.children = [];\n            let child = element.firstElementChild;\n            while (child && entry.children.length < set.size) {\n                if (set.has(child))\n                    entry.children.push(child);\n                child = child.nextElementSibling;\n            }\n            child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;\n            while (child && entry.children.length < set.size) {\n                if (set.has(child))\n                    entry.children.push(child);\n                child = child.nextElementSibling;\n            }\n        }\n        entry.children.forEach(visit);\n    }\n    roots.forEach(visit);\n    return result;\n}\n\n\n/***/ }),\n\n/***/ \"./src/server/supplements/injected/recorder.ts\":\n/*!*****************************************************!*\\\n  !*** ./src/server/supplements/injected/recorder.ts ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Recorder = void 0;\nconst selectorGenerator_1 = __webpack_require__(/*! ./selectorGenerator */ \"./src/server/supplements/injected/selectorGenerator.ts\");\nconst scriptSymbol = Symbol('scriptSymbol');\nclass Recorder {\n    constructor(injectedScript, params) {\n        this._performingAction = false;\n        this._highlightElements = [];\n        this._listeners = [];\n        this._hoveredModel = null;\n        this._hoveredElement = null;\n        this._activeModel = null;\n        this._expectProgrammaticKeyUp = false;\n        this._mode = 'none';\n        this._params = params;\n        this._injectedScript = injectedScript;\n        this._outerGlassPaneElement = document.createElement('x-pw-glass');\n        this._outerGlassPaneElement.style.position = 'fixed';\n        this._outerGlassPaneElement.style.top = '0';\n        this._outerGlassPaneElement.style.right = '0';\n        this._outerGlassPaneElement.style.bottom = '0';\n        this._outerGlassPaneElement.style.left = '0';\n        this._outerGlassPaneElement.style.zIndex = '2147483647';\n        this._outerGlassPaneElement.style.pointerEvents = 'none';\n        this._outerGlassPaneElement.style.display = 'flex';\n        this._tooltipElement = document.createElement('x-pw-tooltip');\n        this._actionPointElement = document.createElement('x-pw-action-point');\n        this._actionPointElement.setAttribute('hidden', 'true');\n        this._innerGlassPaneElement = document.createElement('x-pw-glass-inner');\n        this._innerGlassPaneElement.style.flex = 'auto';\n        this._innerGlassPaneElement.appendChild(this._tooltipElement);\n        // Use a closed shadow root to prevent selectors matching our internal previews.\n        this._glassPaneShadow = this._outerGlassPaneElement.attachShadow({ mode: this._params.isUnderTest ? 'open' : 'closed' });\n        this._glassPaneShadow.appendChild(this._innerGlassPaneElement);\n        this._glassPaneShadow.appendChild(this._actionPointElement);\n        const styleElement = document.createElement('style');\n        styleElement.textContent = `\n        x-pw-tooltip {\n          align-items: center;\n          backdrop-filter: blur(5px);\n          background-color: rgba(0, 0, 0, 0.7);\n          border-radius: 2px;\n          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,\n                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,\n                      rgba(0, 0, 0, 0.1) 0px -2px 4px,\n                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,\n                      rgba(0, 0, 0, 0.25) 0px 54px 55px;\n          color: rgb(204, 204, 204);\n          display: none;\n          font-family: 'Dank Mono', 'Operator Mono', Inconsolata, 'Fira Mono',\n                       'SF Mono', Monaco, 'Droid Sans Mono', 'Source Code Pro', monospace;\n          font-size: 12.8px;\n          font-weight: normal;\n          left: 0;\n          line-height: 1.5;\n          max-width: 600px;\n          padding: 3.2px 5.12px 3.2px;\n          position: absolute;\n          top: 0;\n        }\n        x-pw-action-point {\n          position: absolute;\n          width: 20px;\n          height: 20px;\n          background: red;\n          border-radius: 10px;\n          pointer-events: none;\n          margin: -10px 0 0 -10px;\n          z-index: 2;\n        }\n        *[hidden] {\n          display: none !important;\n        }\n    `;\n        this._glassPaneShadow.appendChild(styleElement);\n        this._refreshListenersIfNeeded();\n        setInterval(() => {\n            this._refreshListenersIfNeeded();\n            if (params.isUnderTest && !this._reportedReadyForTest) {\n                this._reportedReadyForTest = true;\n                console.error('Recorder script ready for test');\n            }\n        }, 500);\n        globalThis._playwrightRefreshOverlay = () => {\n            this._pollRecorderMode().catch(e => console.log(e)); // eslint-disable-line no-console\n        };\n        globalThis._playwrightRefreshOverlay();\n    }\n    _refreshListenersIfNeeded() {\n        if (document.documentElement[scriptSymbol])\n            return;\n        document.documentElement[scriptSymbol] = true;\n        removeEventListeners(this._listeners);\n        this._listeners = [\n            addEventListener(document, 'click', event => this._onClick(event), true),\n            addEventListener(document, 'auxclick', event => this._onClick(event), true),\n            addEventListener(document, 'input', event => this._onInput(event), true),\n            addEventListener(document, 'keydown', event => this._onKeyDown(event), true),\n            addEventListener(document, 'keyup', event => this._onKeyUp(event), true),\n            addEventListener(document, 'mousedown', event => this._onMouseDown(event), true),\n            addEventListener(document, 'mouseup', event => this._onMouseUp(event), true),\n            addEventListener(document, 'mousemove', event => this._onMouseMove(event), true),\n            addEventListener(document, 'mouseleave', event => this._onMouseLeave(event), true),\n            addEventListener(document, 'focus', () => this._onFocus(), true),\n            addEventListener(document, 'scroll', () => {\n                this._hoveredModel = null;\n                this._actionPointElement.hidden = true;\n                this._updateHighlight();\n            }, true),\n        ];\n        document.documentElement.appendChild(this._outerGlassPaneElement);\n    }\n    async _pollRecorderMode() {\n        var _a;\n        const pollPeriod = 1000;\n        if (this._pollRecorderModeTimer)\n            clearTimeout(this._pollRecorderModeTimer);\n        const state = await globalThis._playwrightRecorderState().catch(e => null);\n        if (!state) {\n            this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);\n            return;\n        }\n        const { mode, actionPoint, actionSelector } = state;\n        if (mode !== this._mode) {\n            this._mode = mode;\n            this._clearHighlight();\n        }\n        if (actionPoint && this._actionPoint && actionPoint.x === this._actionPoint.x && actionPoint.y === this._actionPoint.y) {\n            // All good.\n        }\n        else if (!actionPoint && !this._actionPoint) {\n            // All good.\n        }\n        else {\n            if (actionPoint) {\n                this._actionPointElement.style.top = actionPoint.y + 'px';\n                this._actionPointElement.style.left = actionPoint.x + 'px';\n                this._actionPointElement.hidden = false;\n            }\n            else {\n                this._actionPointElement.hidden = true;\n            }\n            this._actionPoint = actionPoint;\n        }\n        // Race or scroll.\n        if (this._actionSelector && !((_a = this._hoveredModel) === null || _a === void 0 ? void 0 : _a.elements.length))\n            this._actionSelector = undefined;\n        if (actionSelector !== this._actionSelector) {\n            this._hoveredModel = actionSelector ? selectorGenerator_1.querySelector(this._injectedScript, actionSelector, document) : null;\n            this._updateHighlight();\n            this._actionSelector = actionSelector;\n        }\n        this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);\n    }\n    _clearHighlight() {\n        this._hoveredModel = null;\n        this._activeModel = null;\n        this._updateHighlight();\n    }\n    _actionInProgress(event) {\n        // If Playwright is performing action for us, bail.\n        if (this._performingAction)\n            return true;\n        // Consume as the first thing.\n        consumeEvent(event);\n        return false;\n    }\n    _consumedDueToNoModel(event, model) {\n        if (model)\n            return false;\n        consumeEvent(event);\n        return true;\n    }\n    _consumedDueWrongTarget(event) {\n        if (this._activeModel && this._activeModel.elements[0] === this._deepEventTarget(event))\n            return false;\n        consumeEvent(event);\n        return true;\n    }\n    _onClick(event) {\n        if (this._mode === 'inspecting')\n            globalThis._playwrightRecorderSetSelector(this._hoveredModel ? this._hoveredModel.selector : '');\n        if (this._shouldIgnoreMouseEvent(event))\n            return;\n        if (this._actionInProgress(event))\n            return;\n        if (this._consumedDueToNoModel(event, this._hoveredModel))\n            return;\n        const checkbox = asCheckbox(this._deepEventTarget(event));\n        if (checkbox) {\n            // Interestingly, inputElement.checked is reversed inside this event handler.\n            this._performAction({\n                name: checkbox.checked ? 'check' : 'uncheck',\n                selector: this._hoveredModel.selector,\n                signals: [],\n            });\n            return;\n        }\n        this._performAction({\n            name: 'click',\n            selector: this._hoveredModel.selector,\n            signals: [],\n            button: buttonForEvent(event),\n            modifiers: modifiersForEvent(event),\n            clickCount: event.detail\n        });\n    }\n    _shouldIgnoreMouseEvent(event) {\n        const target = this._deepEventTarget(event);\n        if (this._mode === 'none')\n            return true;\n        if (this._mode === 'inspecting') {\n            consumeEvent(event);\n            return true;\n        }\n        const nodeName = target.nodeName;\n        if (nodeName === 'SELECT')\n            return true;\n        if (nodeName === 'INPUT' && ['date'].includes(target.type))\n            return true;\n        return false;\n    }\n    _onMouseDown(event) {\n        if (this._shouldIgnoreMouseEvent(event))\n            return;\n        if (!this._performingAction)\n            consumeEvent(event);\n        this._activeModel = this._hoveredModel;\n    }\n    _onMouseUp(event) {\n        if (this._shouldIgnoreMouseEvent(event))\n            return;\n        if (!this._performingAction)\n            consumeEvent(event);\n    }\n    _onMouseMove(event) {\n        if (this._mode === 'none')\n            return;\n        const target = this._deepEventTarget(event);\n        if (this._hoveredElement === target)\n            return;\n        this._hoveredElement = target;\n        this._updateModelForHoveredElement();\n    }\n    _onMouseLeave(event) {\n        // Leaving iframe.\n        if (this._deepEventTarget(event).nodeType === Node.DOCUMENT_NODE) {\n            this._hoveredElement = null;\n            this._updateModelForHoveredElement();\n        }\n    }\n    _onFocus() {\n        const activeElement = this._deepActiveElement(document);\n        const result = activeElement ? selectorGenerator_1.generateSelector(this._injectedScript, activeElement) : null;\n        this._activeModel = result && result.selector ? result : null;\n        if (this._params.isUnderTest)\n            console.error('Highlight updated for test: ' + (result ? result.selector : null));\n    }\n    _updateModelForHoveredElement() {\n        if (!this._hoveredElement) {\n            this._hoveredModel = null;\n            this._updateHighlight();\n            return;\n        }\n        const hoveredElement = this._hoveredElement;\n        const { selector, elements } = selectorGenerator_1.generateSelector(this._injectedScript, hoveredElement);\n        if ((this._hoveredModel && this._hoveredModel.selector === selector) || this._hoveredElement !== hoveredElement)\n            return;\n        this._hoveredModel = selector ? { selector, elements } : null;\n        this._updateHighlight();\n        if (this._params.isUnderTest)\n            console.error('Highlight updated for test: ' + selector);\n    }\n    _updateHighlight() {\n        const elements = this._hoveredModel ? this._hoveredModel.elements : [];\n        // Code below should trigger one layout and leave with the\n        // destroyed layout.\n        // Destroy the layout\n        this._tooltipElement.textContent = this._hoveredModel ? this._hoveredModel.selector : '';\n        this._tooltipElement.style.top = '0';\n        this._tooltipElement.style.left = '0';\n        this._tooltipElement.style.display = 'flex';\n        // Trigger layout.\n        const boxes = elements.map(e => e.getBoundingClientRect());\n        const tooltipWidth = this._tooltipElement.offsetWidth;\n        const tooltipHeight = this._tooltipElement.offsetHeight;\n        const totalWidth = this._innerGlassPaneElement.offsetWidth;\n        const totalHeight = this._innerGlassPaneElement.offsetHeight;\n        // Destroy the layout again.\n        if (boxes.length) {\n            const primaryBox = boxes[0];\n            let anchorLeft = primaryBox.left;\n            if (anchorLeft + tooltipWidth > totalWidth - 5)\n                anchorLeft = totalWidth - tooltipWidth - 5;\n            let anchorTop = primaryBox.bottom + 5;\n            if (anchorTop + tooltipHeight > totalHeight - 5) {\n                // If can't fit below, either position above...\n                if (primaryBox.top > tooltipHeight + 5) {\n                    anchorTop = primaryBox.top - tooltipHeight - 5;\n                }\n                else {\n                    // Or on top in case of large element\n                    anchorTop = totalHeight - 5 - tooltipHeight;\n                }\n            }\n            this._tooltipElement.style.top = anchorTop + 'px';\n            this._tooltipElement.style.left = anchorLeft + 'px';\n        }\n        else {\n            this._tooltipElement.style.display = 'none';\n        }\n        const pool = this._highlightElements;\n        this._highlightElements = [];\n        for (const box of boxes) {\n            const highlightElement = pool.length ? pool.shift() : this._createHighlightElement();\n            const color = this._mode === 'recording' ? '#dc6f6f7f' : '#6fa8dc7f';\n            highlightElement.style.backgroundColor = this._highlightElements.length ? '#f6b26b7f' : color;\n            highlightElement.style.left = box.x + 'px';\n            highlightElement.style.top = box.y + 'px';\n            highlightElement.style.width = box.width + 'px';\n            highlightElement.style.height = box.height + 'px';\n            highlightElement.style.display = 'block';\n            this._highlightElements.push(highlightElement);\n        }\n        for (const highlightElement of pool) {\n            highlightElement.style.display = 'none';\n            this._highlightElements.push(highlightElement);\n        }\n    }\n    _createHighlightElement() {\n        const highlightElement = document.createElement('x-pw-highlight');\n        highlightElement.style.position = 'absolute';\n        highlightElement.style.top = '0';\n        highlightElement.style.left = '0';\n        highlightElement.style.width = '0';\n        highlightElement.style.height = '0';\n        highlightElement.style.boxSizing = 'border-box';\n        this._glassPaneShadow.appendChild(highlightElement);\n        return highlightElement;\n    }\n    _onInput(event) {\n        if (this._mode !== 'recording')\n            return true;\n        const target = this._deepEventTarget(event);\n        if (['INPUT', 'TEXTAREA'].includes(target.nodeName)) {\n            const inputElement = target;\n            const elementType = (inputElement.type || '').toLowerCase();\n            if (elementType === 'checkbox') {\n                // Checkbox is handled in click, we can't let input trigger on checkbox - that would mean we dispatched click events while recording.\n                return;\n            }\n            if (elementType === 'file') {\n                globalThis._playwrightRecorderRecordAction({\n                    name: 'setInputFiles',\n                    selector: this._activeModel.selector,\n                    signals: [],\n                    files: [...(inputElement.files || [])].map(file => file.name),\n                });\n                return;\n            }\n            // Non-navigating actions are simply recorded by Playwright.\n            if (this._consumedDueWrongTarget(event))\n                return;\n            globalThis._playwrightRecorderRecordAction({\n                name: 'fill',\n                selector: this._activeModel.selector,\n                signals: [],\n                text: inputElement.value,\n            });\n        }\n        if (target.nodeName === 'SELECT') {\n            const selectElement = target;\n            if (this._actionInProgress(event))\n                return;\n            this._performAction({\n                name: 'select',\n                selector: this._hoveredModel.selector,\n                options: [...selectElement.selectedOptions].map(option => option.value),\n                signals: []\n            });\n        }\n    }\n    _shouldGenerateKeyPressFor(event) {\n        // Backspace, Delete, AltGraph are changing input, will handle it there.\n        if (['Backspace', 'Delete', 'AltGraph'].includes(event.key))\n            return false;\n        // Ignore the QWERTZ shortcut for creating a at sign on MacOS\n        if (event.key === '@' && event.code === 'KeyL')\n            return false;\n        // Allow and ignore common used shortcut for pasting.\n        if (navigator.platform.includes('Mac')) {\n            if (event.key === 'v' && event.metaKey)\n                return false;\n        }\n        else {\n            if (event.key === 'v' && event.ctrlKey)\n                return false;\n            if (event.key === 'Insert' && event.shiftKey)\n                return false;\n        }\n        if (['Shift', 'Control', 'Meta', 'Alt'].includes(event.key))\n            return false;\n        const hasModifier = event.ctrlKey || event.altKey || event.metaKey;\n        if (event.key.length === 1 && !hasModifier)\n            return !!asCheckbox(this._deepEventTarget(event));\n        return true;\n    }\n    _onKeyDown(event) {\n        if (this._mode === 'inspecting') {\n            consumeEvent(event);\n            return;\n        }\n        if (this._mode !== 'recording')\n            return true;\n        if (!this._shouldGenerateKeyPressFor(event))\n            return;\n        if (this._actionInProgress(event)) {\n            this._expectProgrammaticKeyUp = true;\n            return;\n        }\n        if (this._consumedDueWrongTarget(event))\n            return;\n        // Similarly to click, trigger checkbox on key event, not input.\n        if (event.key === ' ') {\n            const checkbox = asCheckbox(this._deepEventTarget(event));\n            if (checkbox) {\n                this._performAction({\n                    name: checkbox.checked ? 'uncheck' : 'check',\n                    selector: this._activeModel.selector,\n                    signals: [],\n                });\n                return;\n            }\n        }\n        this._performAction({\n            name: 'press',\n            selector: this._activeModel.selector,\n            signals: [],\n            key: event.key,\n            modifiers: modifiersForEvent(event),\n        });\n    }\n    _onKeyUp(event) {\n        if (!this._shouldGenerateKeyPressFor(event))\n            return;\n        // Only allow programmatic keyups, ignore user input.\n        if (!this._expectProgrammaticKeyUp) {\n            consumeEvent(event);\n            return;\n        }\n        this._expectProgrammaticKeyUp = false;\n    }\n    async _performAction(action) {\n        this._performingAction = true;\n        await globalThis._playwrightRecorderPerformAction(action).catch(() => { });\n        this._performingAction = false;\n        // Action could have changed DOM, update hovered model selectors.\n        this._updateModelForHoveredElement();\n        // If that was a keyboard action, it similarly requires new selectors for active model.\n        this._onFocus();\n        if (this._params.isUnderTest) {\n            // Serialize all to string as we cannot attribute console message to isolated world\n            // in Firefox.\n            console.error('Action performed for test: ' + JSON.stringify({\n                hovered: this._hoveredModel ? this._hoveredModel.selector : null,\n                active: this._activeModel ? this._activeModel.selector : null,\n            }));\n        }\n    }\n    _deepEventTarget(event) {\n        return event.composedPath()[0];\n    }\n    _deepActiveElement(document) {\n        let activeElement = document.activeElement;\n        while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n            activeElement = activeElement.shadowRoot.activeElement;\n        return activeElement;\n    }\n}\nexports.Recorder = Recorder;\nfunction modifiersForEvent(event) {\n    return (event.altKey ? 1 : 0) | (event.ctrlKey ? 2 : 0) | (event.metaKey ? 4 : 0) | (event.shiftKey ? 8 : 0);\n}\nfunction buttonForEvent(event) {\n    switch (event.which) {\n        case 1: return 'left';\n        case 2: return 'middle';\n        case 3: return 'right';\n    }\n    return 'left';\n}\nfunction consumeEvent(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n}\nfunction asCheckbox(node) {\n    if (!node || node.nodeName !== 'INPUT')\n        return null;\n    const inputElement = node;\n    return inputElement.type === 'checkbox' ? inputElement : null;\n}\nfunction addEventListener(target, eventName, listener, useCapture) {\n    target.addEventListener(eventName, listener, useCapture);\n    const remove = () => {\n        target.removeEventListener(eventName, listener, useCapture);\n    };\n    return remove;\n}\nfunction removeEventListeners(listeners) {\n    for (const listener of listeners)\n        listener();\n    listeners.splice(0, listeners.length);\n}\nexports.default = Recorder;\n\n\n/***/ }),\n\n/***/ \"./src/server/supplements/injected/selectorGenerator.ts\":\n/*!**************************************************************!*\\\n  !*** ./src/server/supplements/injected/selectorGenerator.ts ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateSelector = exports.querySelector = void 0;\nconst selectorEvaluator_1 = __webpack_require__(/*! ../../injected/selectorEvaluator */ \"./src/server/injected/selectorEvaluator.ts\");\nconst cacheAllowText = new Map();\nconst cacheDisallowText = new Map();\nfunction querySelector(injectedScript, selector, ownerDocument) {\n    try {\n        const parsedSelector = injectedScript.parseSelector(selector);\n        return {\n            selector,\n            elements: injectedScript.querySelectorAll(parsedSelector, ownerDocument)\n        };\n    }\n    catch (e) {\n        return {\n            selector,\n            elements: [],\n        };\n    }\n}\nexports.querySelector = querySelector;\nfunction generateSelector(injectedScript, targetElement) {\n    injectedScript._evaluator.begin();\n    try {\n        targetElement = targetElement.closest('button,select,input,[role=button],[role=checkbox],[role=radio]') || targetElement;\n        const targetTokens = generateSelectorFor(injectedScript, targetElement);\n        const bestTokens = targetTokens || [cssFallback(injectedScript, targetElement)];\n        const selector = joinTokens(bestTokens);\n        const parsedSelector = injectedScript.parseSelector(selector);\n        return {\n            selector,\n            elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)\n        };\n    }\n    finally {\n        cacheAllowText.clear();\n        cacheDisallowText.clear();\n        injectedScript._evaluator.end();\n    }\n}\nexports.generateSelector = generateSelector;\nfunction filterRegexTokens(textCandidates) {\n    // Filter out regex-based selectors for better performance.\n    return textCandidates.filter(c => c[0].selector[0] !== '/');\n}\nfunction generateSelectorFor(injectedScript, targetElement) {\n    if (targetElement.ownerDocument.documentElement === targetElement)\n        return [{ engine: 'css', selector: 'html', score: 1 }];\n    const calculate = (element, allowText) => {\n        const allowNthMatch = element === targetElement;\n        let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement).map(token => [token]) : [];\n        if (element !== targetElement) {\n            // Do not use regex for parent elements (for performance).\n            textCandidates = filterRegexTokens(textCandidates);\n        }\n        const noTextCandidates = buildCandidates(injectedScript, element).map(token => [token]);\n        // First check all text and non-text candidates for the element.\n        let result = chooseFirstSelector(injectedScript, targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch);\n        // Do not use regex for chained selectors (for performance).\n        textCandidates = filterRegexTokens(textCandidates);\n        const checkWithText = (textCandidatesToUse) => {\n            // Use the deepest possible text selector - works pretty good and saves on compute time.\n            const allowParentText = allowText && !textCandidatesToUse.length;\n            const candidates = [...textCandidatesToUse, ...noTextCandidates].filter(c => {\n                if (!result)\n                    return true;\n                return combineScores(c) < combineScores(result);\n            });\n            // This is best theoretically possible candidate from the current parent.\n            // We use the fact that widening the scope to grand-parent makes any selector\n            // even less likely to match.\n            let bestPossibleInParent = candidates[0];\n            if (!bestPossibleInParent)\n                return;\n            for (let parent = parentElementOrShadowHost(element); parent; parent = parentElementOrShadowHost(parent)) {\n                const parentTokens = calculateCached(parent, allowParentText);\n                if (!parentTokens)\n                    continue;\n                // Even the best selector won't be too good - skip this parent.\n                if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\n                    continue;\n                // Update the best candidate that finds \"element\" in the \"parent\".\n                bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch);\n                if (!bestPossibleInParent)\n                    return;\n                const combined = [...parentTokens, ...bestPossibleInParent];\n                if (!result || combineScores(combined) < combineScores(result))\n                    result = combined;\n            }\n        };\n        checkWithText(textCandidates);\n        // Allow skipping text on the target element, and using text on one of the parents.\n        if (element === targetElement && textCandidates.length)\n            checkWithText([]);\n        return result;\n    };\n    const calculateCached = (element, allowText) => {\n        const cache = allowText ? cacheAllowText : cacheDisallowText;\n        let value = cache.get(element);\n        if (value === undefined) {\n            value = calculate(element, allowText);\n            cache.set(element, value);\n        }\n        return value;\n    };\n    return calculateCached(targetElement, true);\n}\nfunction buildCandidates(injectedScript, element) {\n    const candidates = [];\n    for (const attribute of ['data-testid', 'data-test-id', 'data-test']) {\n        if (element.hasAttribute(attribute))\n            candidates.push({ engine: 'css', selector: `[${attribute}=${quoteString(element.getAttribute(attribute))}]`, score: 1 });\n    }\n    if (element.nodeName === 'INPUT') {\n        const input = element;\n        if (input.placeholder)\n            candidates.push({ engine: 'css', selector: `[placeholder=${quoteString(input.placeholder)}]`, score: 10 });\n    }\n    if (element.hasAttribute('aria-label'))\n        candidates.push({ engine: 'css', selector: `[aria-label=${quoteString(element.getAttribute('aria-label'))}]`, score: 10 });\n    if (element.getAttribute('alt') && ['APPLET', 'AREA', 'IMG', 'INPUT'].includes(element.nodeName))\n        candidates.push({ engine: 'css', selector: `${element.nodeName.toLowerCase()}[alt=${quoteString(element.getAttribute('alt'))}]`, score: 10 });\n    if (element.hasAttribute('role'))\n        candidates.push({ engine: 'css', selector: `${element.nodeName.toLocaleLowerCase()}[role=${quoteString(element.getAttribute('role'))}]`, score: 50 });\n    if (element.getAttribute('name') && ['BUTTON', 'FORM', 'FIELDSET', 'IFRAME', 'INPUT', 'KEYGEN', 'OBJECT', 'OUTPUT', 'SELECT', 'TEXTAREA', 'MAP', 'META', 'PARAM'].includes(element.nodeName))\n        candidates.push({ engine: 'css', selector: `${element.nodeName.toLowerCase()}[name=${quoteString(element.getAttribute('name'))}]`, score: 50 });\n    if (['INPUT', 'TEXTAREA'].includes(element.nodeName) && element.getAttribute('type') !== 'hidden') {\n        if (element.getAttribute('type'))\n            candidates.push({ engine: 'css', selector: `${element.nodeName.toLowerCase()}[type=${quoteString(element.getAttribute('type'))}]`, score: 50 });\n    }\n    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(element.nodeName))\n        candidates.push({ engine: 'css', selector: element.nodeName.toLowerCase(), score: 50 });\n    const idAttr = element.getAttribute('id');\n    if (idAttr && !isGuidLike(idAttr))\n        candidates.push({ engine: 'css', selector: makeSelectorForId(idAttr), score: 100 });\n    candidates.push({ engine: 'css', selector: element.nodeName.toLocaleLowerCase(), score: 200 });\n    return candidates;\n}\nfunction buildTextCandidates(injectedScript, element, allowHasText) {\n    if (element.nodeName === 'SELECT')\n        return [];\n    const text = selectorEvaluator_1.elementText(injectedScript._evaluator, element).full.trim().replace(/\\s+/g, ' ').substring(0, 80);\n    if (!text)\n        return [];\n    const candidates = [];\n    let escaped = text;\n    if (text.includes('\"') || text.includes('>>') || text[0] === '/')\n        escaped = `/.*${escapeForRegex(text)}.*/`;\n    candidates.push({ engine: 'text', selector: escaped, score: 10 });\n    if (allowHasText && escaped === text) {\n        let prefix = element.nodeName.toLocaleLowerCase();\n        if (element.hasAttribute('role'))\n            prefix += `[role=${quoteString(element.getAttribute('role'))}]`;\n        candidates.push({ engine: 'css', selector: `${prefix}:has-text(\"${text}\")`, score: 30 });\n    }\n    return candidates;\n}\nfunction parentElementOrShadowHost(element) {\n    if (element.parentElement)\n        return element.parentElement;\n    if (!element.parentNode)\n        return null;\n    if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n        return element.parentNode.host;\n    return null;\n}\nfunction makeSelectorForId(id) {\n    return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? '#' + id : `[id=\"${id}\"]`;\n}\nfunction cssFallback(injectedScript, targetElement) {\n    const kFallbackScore = 10000000;\n    const root = targetElement.ownerDocument;\n    const tokens = [];\n    function uniqueCSSSelector(prefix) {\n        const path = tokens.slice();\n        if (prefix)\n            path.unshift(prefix);\n        const selector = path.join(' ');\n        const parsedSelector = injectedScript.parseSelector(selector);\n        const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument);\n        return node === targetElement ? selector : undefined;\n    }\n    for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n        const nodeName = element.nodeName.toLowerCase();\n        // Element ID is the strongest signal, use it.\n        let bestTokenForLevel = '';\n        if (element.id) {\n            const token = makeSelectorForId(element.id);\n            const selector = uniqueCSSSelector(token);\n            if (selector)\n                return { engine: 'css', selector, score: kFallbackScore };\n            bestTokenForLevel = token;\n        }\n        const parent = element.parentNode;\n        // Combine class names until unique.\n        const classes = [...element.classList];\n        for (let i = 0; i < classes.length; ++i) {\n            const token = '.' + classes.slice(0, i + 1).join('.');\n            const selector = uniqueCSSSelector(token);\n            if (selector)\n                return { engine: 'css', selector, score: kFallbackScore };\n            // Even if not unique, does this subset of classes uniquely identify node as a child?\n            if (!bestTokenForLevel && parent) {\n                const sameClassSiblings = parent.querySelectorAll(token);\n                if (sameClassSiblings.length === 1)\n                    bestTokenForLevel = token;\n            }\n        }\n        // Ordinal is the weakest signal.\n        if (parent) {\n            const siblings = [...parent.children];\n            const sameTagSiblings = siblings.filter(sibling => (sibling).nodeName.toLowerCase() === nodeName);\n            const token = sameTagSiblings.indexOf(element) === 0 ? nodeName : `${nodeName}:nth-child(${1 + siblings.indexOf(element)})`;\n            const selector = uniqueCSSSelector(token);\n            if (selector)\n                return { engine: 'css', selector, score: kFallbackScore };\n            if (!bestTokenForLevel)\n                bestTokenForLevel = token;\n        }\n        else if (!bestTokenForLevel) {\n            bestTokenForLevel = nodeName;\n        }\n        tokens.unshift(bestTokenForLevel);\n    }\n    return { engine: 'css', selector: uniqueCSSSelector(), score: kFallbackScore };\n}\nfunction escapeForRegex(text) {\n    return text.replace(/[.*+?^>${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction quoteString(text) {\n    return `\"${text.replaceAll(/\"/g, '\\\\\"').replaceAll(/\\n/g, '\\\\n')}\"`;\n}\nfunction joinTokens(tokens) {\n    const parts = [];\n    let lastEngine = '';\n    for (const { engine, selector } of tokens) {\n        if (parts.length && (lastEngine !== 'css' || engine !== 'css' || selector.startsWith(':nth-match(')))\n            parts.push('>>');\n        lastEngine = engine;\n        if (engine === 'css')\n            parts.push(selector);\n        else\n            parts.push(`${engine}=${selector}`);\n    }\n    return parts.join(' ');\n}\nfunction combineScores(tokens) {\n    let score = 0;\n    for (let i = 0; i < tokens.length; i++)\n        score += tokens[i].score * (tokens.length - i);\n    return score;\n}\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch) {\n    const joined = selectors.map(tokens => ({ tokens, score: combineScores(tokens) }));\n    joined.sort((a, b) => a.score - b.score);\n    let bestWithIndex = null;\n    for (const { tokens } of joined) {\n        const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\n        const result = injectedScript.querySelectorAll(parsedSelector, scope);\n        const index = result.indexOf(targetElement);\n        if (index === 0) {\n            // We are the first match - found the best selector.\n            return tokens;\n        }\n        // Otherwise, perhaps we can get nth-match?\n        if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\n            continue;\n        // To use nth-match, we must convert everything to css.\n        const allCss = tokens.map(token => {\n            if (token.engine !== 'text')\n                return token;\n            if (token.selector.startsWith('/') && token.selector.endsWith('/'))\n                return { engine: 'css', selector: `:text-matches(\"${token.selector.substring(1, token.selector.length - 1)}\")`, score: token.score };\n            return { engine: 'css', selector: `:text(\"${token.selector}\")`, score: token.score };\n        });\n        const combined = joinTokens(allCss);\n        bestWithIndex = [{ engine: 'css', selector: `:nth-match(${combined}, ${index + 1})`, score: combineScores(allCss) + 1000 }];\n    }\n    return bestWithIndex;\n}\nfunction isGuidLike(id) {\n    let lastCharacterType;\n    let transitionCount = 0;\n    for (let i = 0; i < id.length; ++i) {\n        const c = id[i];\n        let characterType;\n        if (c === '-' || c === '_')\n            continue;\n        if (c >= 'a' && c <= 'z')\n            characterType = 'lower';\n        else if (c >= 'A' && c <= 'Z')\n            characterType = 'upper';\n        else if (c >= '0' && c <= '9')\n            characterType = 'digit';\n        else\n            characterType = 'other';\n        if (characterType === 'lower' && lastCharacterType === 'upper') {\n            lastCharacterType = characterType;\n            continue;\n        }\n        if (lastCharacterType && lastCharacterType !== characterType)\n            ++transitionCount;\n        lastCharacterType = characterType;\n    }\n    return transitionCount >= id.length / 4;\n}\n\n\n/***/ })\n\n/******/ })[\"default\"];";
//# sourceMappingURL=recorderSource.js.map